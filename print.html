<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Docs</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="status.html">Status</a></li><li class="chapter-item expanded "><a href="functional_requirements.html"><strong aria-hidden="true">1.</strong> Functional Requirements</a></li><li class="chapter-item expanded "><a href="modularization.html"><strong aria-hidden="true">2.</strong> Modularization</a></li><li class="chapter-item expanded "><a href="performance_goals.html"><strong aria-hidden="true">3.</strong> Performance Goals</a></li><li class="chapter-item expanded "><a href="threat_model.html"><strong aria-hidden="true">4.</strong> Threat Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threat_model/methodology.html"><strong aria-hidden="true">4.1.</strong> Methodology</a></li><li class="chapter-item expanded "><a href="threat_model/security_assumptions.html"><strong aria-hidden="true">4.2.</strong> Security Assumptions</a></li><li class="chapter-item expanded "><a href="threat_model/application_assets.html"><strong aria-hidden="true">4.3.</strong> Application Assets</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements.html"><strong aria-hidden="true">4.4.</strong> Security Requirements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threat_model/security_requirements/operators.html"><strong aria-hidden="true">4.4.1.</strong> Operators</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/public.html"><strong aria-hidden="true">4.4.2.</strong> Public</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/users.html"><strong aria-hidden="true">4.4.3.</strong> Users</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/clients.html"><strong aria-hidden="true">4.4.4.</strong> Clients</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/federated_homeservers.html"><strong aria-hidden="true">4.4.5.</strong> Federated Homeservers</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/federated_users.html"><strong aria-hidden="true">4.4.6.</strong> Federated Users</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/federated_clients.html"><strong aria-hidden="true">4.4.7.</strong> Federated Clients</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="cryptographic_primitives.html"><strong aria-hidden="true">5.</strong> Cryptographic Primitives and Schemes</a></li><li class="chapter-item expanded "><a href="authentication_systems.html"><strong aria-hidden="true">6.</strong> Authentication in messaging applications</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>This book contains design considerations and documentation for an infrastructure that allows clients to exchange messages via the Messaging Layer Security (MLS) protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-mls-infrastructure-project-status"><a class="header" href="#open-mls-infrastructure-project-status">Open MLS Infrastructure Project Status</a></h1>
<h2 id="update-1-oct-05-2022"><a class="header" href="#update-1-oct-05-2022">Update 1, Oct. 05 2022</a></h2>
<p>The short chapter on <a href="./authentication_systems.html#">authentication systems</a> we add to the book today provides an overview over existing approaches to authentication in secure messaging applications. The report is based on testing, as well as public documentation of the individual applications.</p>
<h2 id="update-0-july-22-2022"><a class="header" href="#update-0-july-22-2022">Update 0, July 22 2022</a></h2>
<p>Today, we publish a <a href="./threat_model.html">threat model</a> for an abstract homeserver that aims fulfills the functional requirements. The threat model also contains privacy and security requirements. This is a first iteration and just like the functional requirements, we expect this to be a living document that grows as we move forward with this project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-requirements"><a class="header" href="#functional-requirements">Functional Requirements</a></h1>
<p>This section describes the functional requirements of a homeserver. Before we detail the individual requirements, we first introduce the different roles that interact with the system.</p>
<p>Note that while the homeserver should ultimately provide the functionality described, the entity in the given role might have to keep state and perform protocol actions to interact with the homeserver.</p>
<h2 id="roles"><a class="header" href="#roles">Roles</a></h2>
<p>A large part of the infrastructure consists of the homeserver, which is operated by the <em>operator</em>. The homeserver exposes most of its API endpoints to <em>clients</em> of <em>users</em> that are registered with the homeserver. The remaining endpoints of the homeserver's API are accessible to <em>the network</em>, as well as <em>federated homeservers</em>. Individuals that are registered with other homeservers are <em>federated users</em> who run <em>federated clients</em>.</p>
<h3 id="operator"><a class="header" href="#operator">Operator</a></h3>
<p>The entity that operates a homeserver. It is assumed to have control over the domain they configure as the homeserver's <em>home domain</em>.</p>
<h3 id="the-network"><a class="header" href="#the-network">The Network</a></h3>
<p>The network includes all entities that have access to the port exposing the homeserver endpoints.</p>
<h3 id="users"><a class="header" href="#users">Users</a></h3>
<p>Users are individuals that have registered as users with the homeserver and that are associated with a unique and immutable <em>user id</em> scoped by the homeserver's home domain. Each user also has a unique <em>user name</em>. Registered users can have one or more registered clients.</p>
<p>The user is ultimately the entity that other users authenticate before starting a conversation.</p>
<p>In the context of federation, users of a given homeserver will sometimes be called <em>local</em> users as opposed to <em>federated</em> users.</p>
<h3 id="clients"><a class="header" href="#clients">Clients</a></h3>
<p>A client is a piece of software associated with and run by a user. The client holds the key material used to authenticate (and thus the user) to other clients and their users. Each client is associated with a <em>client id</em> that is scoped by its user's ID.</p>
<h3 id="federated-homeservers"><a class="header" href="#federated-homeservers">Federated Homeservers</a></h3>
<p>Other instances of the homeserver that are reachable via the network, where both the local and the federated homeserver have been configured to allow mutual federation. Each is assumed to be configured with its own home domain.</p>
<h3 id="federated-users"><a class="header" href="#federated-users">Federated Users</a></h3>
<p>Individuals that have registered with a federated homeserver in the same way as users have with the local one.</p>
<h3 id="federated-clients"><a class="header" href="#federated-clients">Federated Clients</a></h3>
<p>Federated clients are clients which are run by federated users. They are regular clients that are associated with a federated user instead of a local user.</p>
<h2 id="functional-requirements-for-each-role"><a class="header" href="#functional-requirements-for-each-role">Functional Requirements for each Role</a></h2>
<h3 id="functional-requirements-for-homeserver-operators"><a class="header" href="#functional-requirements-for-homeserver-operators">Functional Requirements for Homeserver Operators</a></h3>
<ul>
<li>Homeserver management: Operators MUST be able to configure the homeserver and manage its users locally.</li>
<li>Homedomain setup: Operators MUST be able to set the home domain of the homeserver during setup.</li>
<li>Federation configuration: Operators MUST be able to configure federation: Either by allowlisting other homeservers by their home domain, or by allowing open federation except for a blocklist of home domains for homeservers with which federation is not desired.</li>
</ul>
<h3 id="functional-requirements-for-the-network"><a class="header" href="#functional-requirements-for-the-network">Functional Requirements for the Network</a></h3>
<ul>
<li>User registration: Entities in the public network MUST be able to register a new user.</li>
</ul>
<h3 id="functional-requirements-for-users"><a class="header" href="#functional-requirements-for-users">Functional Requirements for Users</a></h3>
<p>The distinction between users and their clients is difficult because the user will perform most of their interactions with the homeserver through the client. The following is a list of operations performed through the client, which concern the user as their own entity and might thus also affect all of their clients.</p>
<ul>
<li>Client management: Users MUST be able to manage clients (this includes updates to client key material).</li>
<li>Account reset: Users SHOULD be able to reset the account. Members of groups the user is in MUST be notified of the reset.</li>
<li>User name change: Users MUST be able to change their user name. Members of groups the user is in MUST be notified of the new name.</li>
<li>User discovery: Users MUST be able to discover other users.</li>
<li>Connection establishment: Users MUST be able to initialize a connection with previously discovered users (via a two-user MLS group, implies retrieval of <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#section-11">KeyPackages</a> of all of the other user's clients).</li>
<li>Connection rejection: Users MUST be able to accept or reject a connection initialized by another (local or federated) user. The sender of the connection request SHOULD be notified of the acceptance or rejection of the request.</li>
<li>Connection management: Users SHOULD be able to block other (local or federated) users s.t. they don't receive messages from that user anymore. Users SHOULD be able to unblock previously blocked users.</li>
<li>Account deletion: Users MUST be able to delete their account. Members of groups the user is in MUST be notified of the deletion.</li>
</ul>
<h3 id="functional-requirements-for-clients"><a class="header" href="#functional-requirements-for-clients">Functional Requirements for Clients</a></h3>
<p>MLS natively provides a number of group management mechanics such as membership management. The homeserver's task is thus to fulfill the role of an MLS <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#section-4">Delivery Service</a>.</p>
<ul>
<li>Group creation: Clients MUST be able to initialize an MLS group.</li>
<li>Group deletion: Clients MUST be able to delete an MLS group.</li>
<li>Message delivery: Clients MUST be able to asynchronously send <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#section-7">MLS messages</a> to all members of an MLS group that it is a member of (this implies the &quot;filtering server&quot; role specified by the <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#section-4.3">&quot;delivery of messages&quot;</a> requirement of the MLS architecture document). If a given group member has provided the homeserver with a notification for this group, the homeserver MUST attach the notification policy to the message when delivering it. If a group member is a federated client, the homeserver MUST forward the message to the federated homeserver for delivery.</li>
<li>Message queuing: The homeserver MUST store messages sent to a client either by itself or forwarded by a federated homeserver while the client is offline.</li>
<li>Message notifications: Clients MAY provide the homeserver with a means to notify them when a new message is queued, as well as a default notification policy. If the client has provided the homeserver with such a means and corresponding policy, the homeserver MUST notify the client according to either the policy attached to the message, or, if none was attached, according to the default policy.</li>
<li>KeyPackage retrieval: Clients MUST be able to retrieve <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#section-11">KeyPackages</a> for clients of users with a previously established connection (this implies the <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#name-key-storage">&quot;key storage&quot;</a> requirement). As long as there is more than one KeyPackage, the server MUST delete the KeyPackage after it was provided to a (local or federated) client.</li>
<li>Welcome message delivery: Clients MUST be able to send <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#section-13.4.3.1">Welcome</a> messages to clients of users with a previously established connection. If the client has provided the homeserver with a means of notification (and default notification policy), the homeserver MUST notify the client according to the default policy.</li>
<li>Message retrieval: Clients MUST be able to fetch messages queued by the homeserver.</li>
<li>Client authentication: Clients MUST be able to verify the authenticity of MLS leaf <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-credentials">Credentials</a> of clients with which it shares a group (this implies at least partially fulfilling the <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#name-authentication-service">Authentication Service</a> role).</li>
<li>KeyPackage publishing: Clients MUST be able to publish <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#section-11">KeyPackages</a> (this implies the <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#name-key-retrieval">&quot;key retrieval&quot;</a> requirement). When a client publishes new KeyPackages, the homeserver MUST delete all remaining previously uploaded KeyPackages of that client.</li>
<li>Notification configuration: Clients SHOULD be able to configure notification settings of groups of which it is a member.</li>
</ul>
<h3 id="functional-requirements-for-federated-homeservers"><a class="header" href="#functional-requirements-for-federated-homeservers">Functional Requirements for Federated Homeservers</a></h3>
<ul>
<li>Federated message delivery: Federated homeservers MUST be able to send messages for delivery to one of the homeserver's clients.</li>
</ul>
<h3 id="functional-requirements-for-federated-users"><a class="header" href="#functional-requirements-for-federated-users">Functional Requirements for Federated Users</a></h3>
<p>The functional requirements <em>user discovery</em> and <em>connection establishment</em> for local users also apply for federated users.</p>
<h3 id="functional-requirements-for-federated-clients"><a class="header" href="#functional-requirements-for-federated-clients">Functional Requirements for Federated Clients</a></h3>
<p>The functional requirements <em>message delivery</em>, <em>KeyPackage retrieval</em>, <em>welcome message delivery</em>, <em>client authentication</em> and <em>notification configuration</em> for local clients also apply for federated clients.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modularization-and-architecture-overview"><a class="header" href="#modularization-and-architecture-overview">Modularization and Architecture Overview</a></h1>
<p>The requirements sketched above provide a good distribution of services across modules within the homeserver. Here, we provide a list of modules, as well as the functionality we expect them to provide to users and their clients.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<ul>
<li>Delivery service:
<ul>
<li>Initial creation of a group and management of the corresponding state (including addition and removal of members)</li>
<li>Message delivery to members of a given group</li>
</ul>
</li>
<li>Authentication service:
<ul>
<li>Registration of new users</li>
<li>Addition and removal of clients of a given user</li>
<li>User discovery</li>
<li>Authentication of users through their clients</li>
</ul>
</li>
<li>Queuing service:
<ul>
<li>Creation of queues for clients</li>
<li>Enqueuing of messages by the delivery service</li>
<li>Dequeuing of messages by the client owning the queue</li>
</ul>
</li>
<li>KeyPackage service:
<ul>
<li>Upload of KeyPackages</li>
<li>Retrieval of KeyPackages for a given client or user</li>
</ul>
</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The following shows a simplified interface between client and homeserver. Note, that for some of the security requirements (which we will detail in a later report), we might add one or more additional modules. For example, we will likely add a module that provides DDoS protection.</p>
<p><img src="images/homeserver_interface.png" alt="Simplified interface for client ↔ backend communication." /></p>
<p>Simplified interface for client ↔ backend communication.</p>
<h2 id="federated-architecture"><a class="header" href="#federated-architecture">Federated Architecture</a></h2>
<p>We will later generalize the above architecture to work in a federated setting. The general principle here is that individual clients only ever communicate through their own homeserver, so if a client’s query is w.r.t. another client, user or group that exists on another backend, that query will be forwarded accordingly. The target client/user/group’s homeserver is implicit in the GroupId/UserId/QueueId in question.</p>
<p><img src="images/cross_homeserver_flow.png" alt="Sketch of a message delivery from one client across two homeserver. Alice contacts her Delivery Service, which in turn contacts the Queuing Service of Backend 2. Finally, Bob can retrieve the message from his homeserver by contacting the Queuing Service." /></p>
<p>Sketch of a message delivery from one client across two homeserver. Alice contacts her Delivery Service, which in turn contacts the Queuing Service of Backend 2. Finally, Bob can retrieve the message from his homeserver by contacting the Queuing Service.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-goals"><a class="header" href="#performance-goals">Performance goals</a></h1>
<p>The goal of the homeserver(s) is to facilitate messaging for consumers in general and in particular consumers with resource constrained devices such as smartphones running. Despite the advances in battery capacity, memory and computational performance in modern smartphones, consumers should still be able to communicate with the infrastructure without incurring disproportionate resource consumption. Additionally applications should be able to use the infrastructure without requiring exceptions to the restrictions that platforms running on modern smartphones (Android, iOS) impose on applications such as limited computation time when running in the background.</p>
<p>Similarly, homeserver operators should be able to run their servers without a significant overhead in costs due to computation, memory or persistent storage.</p>
<p>Quantifying performance goals is hard, since the hardware differs significantly across vendors. However, since cryptography is going to make up the largest consumer of computation time, as well as memory and persistent storage, we are going to use asymmetric cryptographic operations (public key encryption, signatures) as unit of measurement for computational overhead and number of keys that need to be stored as unit of measurement for memory and persistent storage overhead. This has the added advantage that we can later estimate the additional overhead in case of adoption of a Post-Quantum secure scheme with significantly larger key sizes.</p>
<h2 id="client-queries"><a class="header" href="#client-queries">Client Queries</a></h2>
<ul>
<li>Network overhead: Clients should be able to perform the most commonly used queries (i.e. send a message to a group or retrieve messages from their queue) with a single round-trip. In particular, it should be possible to request own messages in batch, although the service might limit the size each batch of messages retrieved at a time, leading to additional round trips.</li>
<li>Computational overhead: The estimated computational cost for a given query heavily depends on the type of query. Let n be the number of member in a given group.
<ul>
<li>Simple (application) message to a group: One asymmetric operation for both sender and receiver</li>
<li>Message updating encryption key material: Less than 3log(n) asymmetric operations for the sender and less than log(n)</li>
<li>Message updating authentication key material of adding/removing a group member: Same as updating encryption key material plus &lt;10 asymmetric operations per joining client</li>
<li>Joining a new group: between 5n and 10n asymmetric operations</li>
</ul>
</li>
</ul>
<p>Performance constraints are especially important if the respective operations are potentially performed in the background, i.e. when a user is not currently interacting with the client.</p>
<h2 id="homeserver-processing"><a class="header" href="#homeserver-processing">Homeserver Processing</a></h2>
<ul>
<li>Network overhead: Homeservers should typically respond to one message with one response, although fan-out of a message can result in additional messages sent over the network in a federated setting. Note, that disproportionate amplification of network traffic (i.e. one client request causing a number of server requests) will be mitigated by rate limiting measures such as traditional IP-based rate limiting and schemes such as Privacy Pass.</li>
<li>Computational overhead: With the exception of the group joining cost, the computational cost of the server will be roughly equivalent to that of a client processing a given message.</li>
<li>IO overhead: A query from a client should result in at most one read and one write operation from/to the homeserver’s database, although we expect caching to reduce the number of reads significantly.</li>
</ul>
<h2 id="additional-overhead-due-to-rate-limiting"><a class="header" href="#additional-overhead-due-to-rate-limiting">Additional Overhead due to Rate-Limiting</a></h2>
<p>More sophisticated rate limiting measures, such as the Privacy Pass protocol might create additional overhead, such as an occasional additional round-trip and asymmetric operation to retrieve an access token from the homeserver. We estimate the required frequency of this kind of operation to be at most once per day.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threat-model"><a class="header" href="#threat-model">Threat model</a></h1>
<p>This document contains a threat model for an MLS homeserver. For now, this threat model is based solely on its functional requirements. As we build the specification of the homeserver, we will update this document to consider any additional assets.</p>
<h2 id="functional-requirements-1"><a class="header" href="#functional-requirements-1">Functional requirements</a></h2>
<p>The homeserver is expected to fulfill the functional requirements described <a href="./functional_requirements.html">here</a> and to interface with parties fulfilling the roles outlined in that document.</p>
<h2 id="mls-as-underlying-protocol"><a class="header" href="#mls-as-underlying-protocol">MLS as underlying protocol</a></h2>
<p>The homeserver facilitates communication between clients via the Messaging Layer Security (MLS) protocol, which already provides a number of <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#name-intended-security-guarantee">security guarantees</a> which we do not describe here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threat-model-methodology"><a class="header" href="#threat-model-methodology">Threat model methodology</a></h1>
<p>We describe our threat model by roughly following the STRIDE framework as outlined <a href="https://www.securesoftware.nl/resources/FrameworkSecureSoftware_v1.pdf">here</a>. However, we modify the methodology slightly to fit use-case.</p>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>The &quot;Authentication&quot; property as listed in the STRIDE model can apply to multiple entities in a given operation provided by the homeserver. For example, the <em>message delivery</em> action described in the <a href="threat_model/../functional_requirements.html">functional requirements</a> involves the client requesting that the homeserver deliver the message, the homeserver receiving and processing the request, a potential federated homeserver that stores and forwards the request and finally the user receiving the message on the other end.</p>
<p>We thus have three kinds of authentication rather than just one: Client to server (C2S), server to server (S2S) and client to client (C2C), all of which we consider as sub-properties of the authentication property of the STRIDE model.</p>
<h2 id="spam-reduction"><a class="header" href="#spam-reduction">Spam reduction</a></h2>
<p>Spam (outside of its potential for a denial-of-service attack on the homeserver) is a general risk for a messaging service. We talk about spam reduction rather than spam prevention, because we don't believe spam is a problem that can be avoided entirely in a privacy-preserving messenger and instead aim to reduce it to a minimum.</p>
<p>In the context of our threat model, we consider spam potential an additional security risk for every action that leads to messages being sent to users or that otherwise alerts the user, e.g. by triggering a notification. This is reflected by adding the security property <em>spam reduction</em> to the existing STRIDE properties.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-assumptions"><a class="header" href="#security-assumptions">Security assumptions</a></h1>
<p>The operator of a homeserver can leverage its conrol over the homeserver to influence if and how the homeserver serves its users. While the goal of the protocol should be to reduce the amount of control the operator has, there are a few assumptions that need to be made.</p>
<h2 id="operators-are-trusted-not-to-spam-users"><a class="header" href="#operators-are-trusted-not-to-spam-users">Operators are trusted not to spam users</a></h2>
<p>Homeserver operators can circumvent any server-side spam reduction mechanisms and will thus be able to send excessive amounts of messages to a user and their clients (or notifications if the user provides the homeserver with a means to notify them). While the client can impose its own spam reduction mechanisms that the homeserver operator can't circumvent, they will likely also impede the usability of the client.</p>
<h2 id="operators-are-trusted-not-to-deny-services-to-individual-users"><a class="header" href="#operators-are-trusted-not-to-deny-services-to-individual-users">Operators are trusted not to deny services to individual users</a></h2>
<p>The homeserver operator can control which user the homeserver provides its services to and to which ones it doesn't. Metadata minimalism already mitigates this problem to a certain degree, because in most cases, the operator shouldn't know who makes a certain request. However, some actions such as client management or user name changes require explicit authentication, allowing the operator to lock out users in a targeted way. Similarly, the operator can simply delete records of a specific user from the database, or deny a given user the ability to publish KeyPackages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-assets"><a class="header" href="#application-assets">Application assets</a></h1>
<p>The homeserver will have to perform all actions listed for the individual roles in the <a href="threat_model/./functional_requirements.html">functional requirements section</a>.</p>
<p>To fulfill these requirements, the homeserver will keep the following state (information assets in STRIDE terminology). Each piece of state is annotated by the actions involved in its lifecycle.</p>
<ul>
<li>Group state (for message delivery, including associated metadata such as group membership lists)
<ul>
<li>Create: Group creation</li>
<li>Read, Update: Message delivery (with inline MLS group management)</li>
<li>Delete: Group deletion</li>
</ul>
</li>
<li><a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-key-packages">KeyPackages</a> for retrieval by clients
<ul>
<li>Create/Update/Delete: KeyPackage publishing (publication of new KeyPackages implies deletion of old ones)</li>
<li>Read/Delete: KeyPackage retrieval (reading implies deletion, except for <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-keypackage-reuse">KeyPackages of last resort</a>)</li>
</ul>
</li>
<li>Authentication key material of users and their clients
<ul>
<li>Create/Update/Delete: Client management</li>
<li>Update: Account reset</li>
<li>Delete: Account deletion</li>
<li>Read: Client authentication</li>
</ul>
</li>
<li>User names
<ul>
<li>Create: User registration</li>
<li>Update: User name change</li>
<li>Read: User discovery</li>
<li>Delete: Account deletion</li>
</ul>
</li>
</ul>
<p>This section will be extended with more information assets as the specification is written.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-requirements"><a class="header" href="#security-requirements">Security requirements</a></h1>
<p>This section iterates over each role and analyses each action as described in the <a href="threat_model/./../methodology.html">Methodology</a> section.</p>
<p>In addition to any specific security requirements listed in the individual actions, the following general security requirements must hold.</p>
<h2 id="basic-confidentiality-and-authentication"><a class="header" href="#basic-confidentiality-and-authentication">Basic confidentiality and authentication</a></h2>
<p>All actions performed via the network (which includes all actions with the possible exception those of the operator, which may be local, command-line based actions) MUST use be performed through a unilaterally authenticated TLS 1.3 connection using the home domain of the homeserver.</p>
<h2 id="metadata-minimalism"><a class="header" href="#metadata-minimalism">Metadata minimalism</a></h2>
<p>Metadata that is not required to provide functionality at a later point in time MUST be deleted immediately. Similarly, all metadata that is not required to be stored in the clear MUST be stored encrypted-at-rest.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>The actions by the operator only involve the operator and the homeserver. They thus don't involve other authentication beyond the homeserver authenticating the operator.</p>
<p>Since operators are trusted not to spam their users as per <a href="threat_model/security_requirements/../security_assumptions.html">security assumptions</a>, spam prevention will not be listed for operator actions.</p>
<h2 id="homeserver-management"><a class="header" href="#homeserver-management">Homeserver management</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Only operators can perform management actions</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must perform checks to ensure the configuration is valid</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. There is only one homeserver operator</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk. Homeserver management actions are not confidential</td><td></td></tr>
<tr><td>Availability</td><td>Operators should always be able to perform management actions</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. There is only one homeserver operator role</td><td></td></tr>
</tbody></table>
</div>
<h2 id="homeserver-setup"><a class="header" href="#homeserver-setup">Homeserver setup</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Not a risk. The entity setting up the server can only be the operator</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must check if the homeserver domain is a FQDN at startup</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. At the time of setup, identities don't exist yet</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk. The home domain is public</td><td></td></tr>
<tr><td>Availability</td><td>This is a setup action. The homeserver is not running at that time</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. Setup is done by a single entity.</td><td></td></tr>
</tbody></table>
</div>
<h2 id="federation-configuration"><a class="header" href="#federation-configuration">Federation configuration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Only administrators can configure federation</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. Operators are responsible for checking the validity of the configuration</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. There is only one homeserver operator</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk. Federation configuration actions are not confidential</td><td></td></tr>
<tr><td>Availability</td><td>Operators should always be able to manage homeserver federation</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. There is only one homeserver operator role</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="public"><a class="header" href="#public">Public</a></h1>
<h2 id="user-registration"><a class="header" href="#user-registration">User registration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Not a risk. Registration is publicly accessible</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must perform checks to ensure the user name entered is valid as per specification</td><td></td></tr>
<tr><td>Non-repudiation</td><td>The user or its client must prove possession of authentication key material</td><td></td></tr>
<tr><td>Confidentiality</td><td>No requirements besides the <a href="threat_model/security_requirements/../security_requirements.html">general confidentiality requirements</a></td><td></td></tr>
<tr><td>Availability</td><td>User registration MAY be restricted when the homeserver has limited resources</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. No authorization required for registration</td><td></td></tr>
<tr><td>Spam prevention</td><td>To mitigate spam attacks downstream of user registration, the homeserver MAY restrict user registration</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="users-1"><a class="header" href="#users-1">Users</a></h1>
<p>TODO: Maybe note somewhere generally how notifications, or more generally client-to-client messages must be authenticated? This seems to repeat here and in the client's section.</p>
<h2 id="client-management"><a class="header" href="#client-management">Client management</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication (C2S)</td><td>Users can only manage their own clients</td><td></td></tr>
<tr><td>Authentication (C2C)</td><td>The user's contacts (local and federated) must be able to authenticate the user's actions end-to-end</td><td></td></tr>
<tr><td>Authentication (S2S)</td><td>A federated homeserver forwarding a notification must be able to authenticate the users's homeserver as origin</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. Users are responsible for the integrity of their own clients</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Other clients of the user must be able to determine which client performed the action</td><td></td></tr>
<tr><td></td><td>The user's contacts must be notified of the action</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk. A user's client management is considered public</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to manage their own clients</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. The user can manage clients through any of their clients</td><td></td></tr>
<tr><td>Spam prevention</td><td>Client management actions should be limited, as they are message sending</td><td></td></tr>
</tbody></table>
</div>
<h2 id="account-reset"><a class="header" href="#account-reset">Account reset</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Users can only reset their own accounts</td><td></td></tr>
<tr><td>Authentication (C2C)</td><td>The user's contacts (local and federated) must be able to authenticate the user's actions end-to-end</td><td></td></tr>
<tr><td>Authentication (S2S)</td><td>A federated homeserver forwarding a notification must be able to authenticate the users's homeserver as origin</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. A reset replaces all user data except the user name</td><td></td></tr>
<tr><td>Non-repudiation</td><td>The users contacts must be notified of the user's account reset</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk. No confidential user data is transmitted during an account reset</td><td></td></tr>
<tr><td>Availability</td><td>Users should be able to reset their own account once every month</td><td>TODO: Is this the time frame we want?</td></tr>
<tr><td>Authorization</td><td>Not a risk. The user is the only entity that can perform this action</td><td></td></tr>
<tr><td>Spam prevention</td><td>The homeserver must limit the number of account resets, as they are message sending</td><td></td></tr>
</tbody></table>
</div>
<h2 id="user-name-change"><a class="header" href="#user-name-change">User name change</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Users can only change their own user name</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must ensure the new user name is valid</td><td>(see user registration)</td></tr>
<tr><td>Non-repudiation</td><td>The users contacts must be notified of the user's user name change</td><td></td></tr>
<tr><td>Confidentiality</td><td>The new user name must be communicated to contacts end-to-end encrypted</td><td></td></tr>
<tr><td>Availability</td><td>Users should be able to change their user name once every month</td><td>TODO: Is this the time frame we want?</td></tr>
<tr><td>Authorization</td><td>Not a risk. The user is the only entity that can perform this action</td><td></td></tr>
<tr><td>Spam prevention</td><td>The homeserver must limit the number of user name changes, as they are message sending</td><td></td></tr>
</tbody></table>
</div>
<h2 id="user-discovery"><a class="header" href="#user-discovery">User discovery</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>All registered users should be able to discover other users by their full user name</td><td></td></tr>
<tr><td></td><td>Users must be able to authenticate any user information in an end-to-end way</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. End-to-end authentication implies integrity of the data</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. Users must be able to discover other users anonymously</td><td></td></tr>
<tr><td>Confidentiality</td><td>The user must be able to perform discovery anonymously</td><td></td></tr>
<tr><td></td><td>Users should only be able to discover a limited number of users every day</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to discover users with the given confidentiality restrictions</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to discover other users</td><td></td></tr>
<tr><td>Spam prevention</td><td>Not a risk. Discovering a user should not be message sending</td><td></td></tr>
</tbody></table>
</div>
<h2 id="connection-establishment"><a class="header" href="#connection-establishment">Connection establishment</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>All registered users should be able to establish connections to other users</td><td></td></tr>
<tr><td></td><td>The establishing user must be able to authenticate the target user</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. Authentication implies integrity of the connection request</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. Users must be able to establish connections anonymously</td><td></td></tr>
<tr><td>Confidentiality</td><td>The user must be able to establish connections anonymously w.r.t. the homeserver</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to establish connections (limited by anti-spam measures)</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to establish connections</td><td></td></tr>
<tr><td>Spam prevention</td><td>High spam risk. Connection establishments are message sending must be limited per user</td><td></td></tr>
</tbody></table>
</div>
<h2 id="connection-rejection"><a class="header" href="#connection-rejection">Connection rejection</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>All registered users should be able to accept/reject incoming connections requests</td><td></td></tr>
<tr><td></td><td>The accepting/rejecting user must be able to authenticate the requesting user</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. Authentication implies integrity of the connection request</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk as long as connection requests can be authenticated by the receiving user</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk as long as transport encryption and metadata minimalism are upheld</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to accept or reject connections</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to accept/reject connections</td><td></td></tr>
<tr><td>Spam prevention</td><td>Connection accepts/rejects are message sending and thus have to be limited</td><td>TODO: Is this really message sending?</td></tr>
</tbody></table>
</div>
<h2 id="connection-management"><a class="header" href="#connection-management">Connection management</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>All registered users should be able to manage their existing connections</td><td></td></tr>
<tr><td></td><td>Each user should only be able to manage their own connections</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. Clients are responsible for their own list of connections</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. Connection management does not need to be logged</td><td></td></tr>
<tr><td>Confidentiality</td><td>The homeserver should not learn which connections a user has</td><td></td></tr>
<tr><td></td><td>The homeserver should not learn which users a user has blocked</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to manage their own connections</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to accept/reject (their own) connections</td><td></td></tr>
<tr><td>Spam prevention</td><td>Connection management is message sending and thus has to be limited</td><td>TODO: Is this really message sending?</td></tr>
</tbody></table>
</div>
<h2 id="account-deletion"><a class="header" href="#account-deletion">Account deletion</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>All registered users should be able to delete their won account</td><td></td></tr>
<tr><td></td><td>Each user should only be able to delete their own account</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk, as there should be no data left after deletion</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. Account deletion should not be logged</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk as long as transport encryption and metadata mimimalism hold</td><td></td></tr>
<tr><td></td><td>In particular, all metadata regarding the deleted account should be deleted</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to delete their own account</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to delete (their own) account</td><td></td></tr>
<tr><td>Spam prevention</td><td>Account deletion is message sending and thus has to be limited</td><td>TODO: Is this really message sending?</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="clients-1"><a class="header" href="#clients-1">Clients</a></h1>
<p>TODO: Add note on group integrity validation and why it's only possible to a certain extent.
TODO: Restructure with C2S, S2S and C2C authentication in mind.</p>
<h2 id="group-creation"><a class="header" href="#group-creation">Group creation</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Only clients of local users can create new groups</td><td></td></tr>
<tr><td></td><td>The group creator has to be able to authenticate itself as the only member of the group</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must perform checks to ensure the group state is valid</td><td>Only possible to a certain extent</td></tr>
<tr><td>Non-repudiation</td><td>Not a risk as long as the authentication requirements hold.</td><td></td></tr>
<tr><td>Confidentiality</td><td>The homeserver must not learn the identity of the group creator</td><td>Authentication can be done pseudonymously</td></tr>
<tr><td>Availability</td><td>Users should always be able to create new groups (limited by anti-spam measures)</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to create groups</td><td></td></tr>
<tr><td>Spam prevention</td><td>The homeserver must limit the number of groups created by a given user</td><td></td></tr>
</tbody></table>
</div>
<h2 id="message-delivery"><a class="header" href="#message-delivery">Message delivery</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Only local or federated clients can send messages</td><td></td></tr>
<tr><td></td><td>Only members of a given group can send messages to that group</td><td></td></tr>
<tr><td></td><td>Members must not be able to send messages on behalf of other members</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must perform checks to ensure the message is valid</td><td>Only possible to a certain extent</td></tr>
<tr><td>Non-repudiation</td><td>Group members must be able to identify the sender of a message</td><td></td></tr>
<tr><td>Confidentiality</td><td>The homeserver must not learn the identity of the sender</td><td>Authentication can be done pseudonymously</td></tr>
<tr><td>Availability</td><td>Users should always be able to send messages to groups that they are members of</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All group members should be able to send messages</td><td></td></tr>
<tr><td>Spam prevention</td><td>The homeserver must limit the number of message deliveries, as they are message sending</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="federated-homeservers-1"><a class="header" href="#federated-homeservers-1">Federated Homeservers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="federated-users-1"><a class="header" href="#federated-users-1">Federated Users</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="federated-clients-1"><a class="header" href="#federated-clients-1">Federated Clients</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptographic-primitives-and-schemes"><a class="header" href="#cryptographic-primitives-and-schemes">Cryptographic primitives and schemes</a></h1>
<p>To fulfill the functional and performance requirements, as well as those for security and privacy, the homeserver will need to employ a number of cryptographic primitives, e.g. signature, authenticated encryption, etc. This chapter discusses the primitives required, as well as the choice of schemes that are used for the initial specification. As customary in other protocol specifications the set of schemes used by a homeserver is called the homeserver's ciphersuite.</p>
<h2 id="federation-and-cryptographic-agility"><a class="header" href="#federation-and-cryptographic-agility">Federation and cryptographic agility</a></h2>
<p>Each homeserver operator will have its own requirements with regard to the ciphersuite that they want to use. This could be, for example, due to the requirement for the primitives to be certified in some way, or to meet a specific level of security for organizational policy reasons.</p>
<p>The underlying Messaging Layer Security (MLS) supports agility for a number of reasons and homeservers should, too.</p>
<p>For the initial homeserver specification, however, only one ciphersuite will be supported, even though the design will accommodate the requirement for homeservers to advertise their ciphersuite support.</p>
<h2 id="list-of-cryptographic-primitives-and-schemes"><a class="header" href="#list-of-cryptographic-primitives-and-schemes">List of cryptographic primitives and schemes</a></h2>
<p>For now, the homeserver is anticipated to require mostly basic symmetric and asymmetric primitives to fulfill its functional requirements. This is with the exception of an unlinkable token scheme to enable rate-limiting while allowing clients to access the homeservers services anonymously.</p>
<p>Along with the list of primitives, the list also includes a concrete scheme for each primitive that will be used in the initial specification.</p>
<p>In addition to the scheme's fitness to facilitate the listed requirements of the homeserver (functional, security, privacy, performance), an implementation of each scheme has to be available and fulfill the following criteria:</p>
<ul>
<li>Open source with an OSI-recognized license</li>
<li>ideally implemented in Rust</li>
<li>actively and well maintained</li>
</ul>
<p>The RustCrypto suite of cryptographic implementations provides well-maintained Rust implementations of a large variety of cryptographic primitives and schemes. While they are generally not as highly optimized for performance as other available implementations, they provide a good baseline that is sufficient for a PoC homeserver implementation. In the future, we hope to upgrade any implementations we decide on for the PoC with similarly well performing ones that have formally verified properties such as functional correctness and secret-independent execution,</p>
<p>When it comes to the concrete choice of primitives and schemes, an easy choice for the initial specification is the suite of schemes in the “mandatory-to-implement” (MTI) ciphersuite of MLS, as it represents a compromise between security and good performance on a variety of devices. In particular, the primitives and schemes are</p>
<ul>
<li>Signatures: Ed25519</li>
<li>Hash function: SHA256</li>
<li>AEAD scheme: AES128-GCM</li>
<li>KEM: DHKEMX25519</li>
</ul>
<p>Additional recommendations for primitives that might be used in the homeserver specification are</p>
<ul>
<li>MAC: HMAC-SHA256</li>
<li>KDF: HKDF-SHA256</li>
</ul>
<p>While these are the schemes that should make up the first ciphersuite of the homeserver, the specification should remain modular, such that multiple schemes can be supported and different versions of the homeserver protocols can introduce or deprecate individual ciphersuites.</p>
<p>All schemes above have been well-tested in a variety of modern, cryptographic protocols (e.g. Signal, TLS). The only choice that might not be immediately obvious is AES128-GCM as AEAD scheme, since in many cases, Chacha20-Poly1905 is frequently used as a more efficient scheme on devices that don’t have hardware support for AES, most of those with ARM processors. However, with the most recent generations of ARM processors supporting AES instructions, AES128-GCM is a good choice for a first ciphersuite, given that support for multiple ciphersuites is planned for the future.</p>
<h2 id="unlinkable-tokens"><a class="header" href="#unlinkable-tokens">Unlinkable tokens</a></h2>
<p>Should unlinkable tokens be used to facilitate a metadata friendly rate-limiting mechanism, their performance is essentially to not ultimately represent a denial of service vulnerability themselves.</p>
<p>Since the Privacy Pass protocol is the only well-known unlinkable token scheme that has seen extensive real-world use and analysis, it is recommended as the protocol of choice for metadata-friendly rate-limiting. Besides its use in practice, it is also on the finishing stretch of the IETF standardization process. Privacy Pass defines a number of token types, each backed by another cryptographic scheme. Performance tests have revealed, however, that all schemes suggested in the draft specification are prohibitively expensive in terms of computational overhead in the various protocol operations. To mitigate this shortcoming, the authors of this document have proposed a new batched token type based on the <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-ristretto255-decaf448/">Ristretto255</a> group (also in the process of IETF standardization), which has significantly improved performance over the schemes used by existing token types. These improved results come at a slight security cost, which can be mitigated by a conservative key rotation policy.</p>
<p>The authors have already performed initial performance tests justifying the effort and published <a href="https://raphaelrobert.github.io/privacypass-batched-tokens/draft-robert-privacypass-batched-tokens.html">a document</a> defining the new token type, as well detailing the security recommendations for consideration by the Privacy Pass working group at the IETF.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-in-messaging-applications"><a class="header" href="#authentication-in-messaging-applications">Authentication in messaging applications</a></h1>
<p>All of the commonly used messaging applications aim to provide authentication as one of their primary security guarantees. The goal is that recipients of a given message can authenticate the sender based on (public) cryptographic key material which we call the sender’s <em>cryptographic identity</em> (for brevity sometimes just <em>identity</em>). The cryptographic identity is typically a signature public key or a public key that can be used in an authenticated key exchange. The holder of the corresponding private key material is the owner of the cryptographic identity.</p>
<p>The recipient can use the cryptographic identity of the sender to either authenticate individual messages (e.g. verifying the sender’s signature on an incoming message using the sender’s public signature key) or to establish an authenticated channel to the sender by way of an initial, authenticated key agreement (e.g. a Diffie-Hellman (DH) style key exchange involving the DH public key of both parties). In both cases, the recipient relies on the fact that the cryptographic identity it uses on for authentication is indeed owned by whom the recipient thinks the sender of the message is.</p>
<p>This leads to the question of how the sender and receiver can ensure (or at least increase their confidence) that the cryptographic identity each has of its peer is correct.</p>
<p>The problem is typically solved by the sender and receiver using a trusted channel to either exchange cryptographic identities or verify them later.</p>
<h2 id="meddler-in-the-middle-mitm-attacks"><a class="header" href="#meddler-in-the-middle-mitm-attacks">Meddler-in-the-middle (MITM) attacks</a></h2>
<p>In both cases, the threat is that an adversary, often called a meddler-in-the-middle <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">sits between sender and receiver</a> and controls the channel they use to exchange messages. When the sender and receiver exchange their respective cryptographic identities, the adversary replaces them with ones that it controls. After such an attack, the adversary can impersonate one victim towards the other, as long as sender and receiver use a channel for communication that the adversary controls.</p>
<h1 id="existing-authentication-concepts"><a class="header" href="#existing-authentication-concepts">Existing authentication concepts</a></h1>
<p>There are many methods for the the recipient to ensure (or gain confidence in the fact) that the cryptographic identity it uses to authenticate the sender of a message corresponds to the private key material held by the original sender.</p>
<p>Some of these methods rely on the properties of the channel used to <strong>exchange</strong> the identities and some on additional ways of <strong>verifying</strong> identities after they were exchanged through a channel with limited trust.</p>
<p>The approaches are not mutually exclusive. Typically messaging systems use at least two of the approaches detailed below.</p>
<h2 id="trust-on-first-use-tofu"><a class="header" href="#trust-on-first-use-tofu">Trust on first use (TOFU)</a></h2>
<p>As the name implies, <a href="https://en.wikipedia.org/wiki/Trust_on_first_use">trust on first use</a> means that the receiver trusts the cryptographic identity of the sender upon initial reception, regardless of the transportation channel.</p>
<p><strong>Threat model:</strong> The adversary either controls the channel, but is passive (can observe, but not tamper with traffic) at the time the exchange happens, or controls the general communication channel, but not the one used to exchange identities.</p>
<h2 id="trusted-third-party-exchange"><a class="header" href="#trusted-third-party-exchange">Trusted third party (exchange)</a></h2>
<p>A typical scenario in the messaging world is where the receiver trusts the cryptographic identity of the sender because it received the identity from a <a href="https://en.wikipedia.org/wiki/Trusted_third_party">trusted third party</a> (TTP). This approach only works if there is a designated trusted third party that all participants of the messaging system are either provisioned with in some way or have an authenticated way of retrieving. Typically, TTPs are no regular participants in the messaging system.</p>
<ul>
<li>The receiver could obtain the sender’s identity from the provider of the messaging service, as long as the cryptographic identity of the messaging service itself was provisioned upon downloading and installing the app.</li>
<li>The receiver could obtain the sender’s identity from the sender’s identity provider, as long as it has some way of discovering the address and cryptographic identity of said provider through an authenticated channel.</li>
</ul>
<p><strong>Threat model:</strong> The adversary actively controls the network, but not the trusted third party. The adversary also can’t interfere with the provisioning process.</p>
<h2 id="out-of-band-verification"><a class="header" href="#out-of-band-verification">Out-of-band verification</a></h2>
<p>To establish trust in the validity of the cryptographic identities of the sender, the recipient party can verify via an <a href="https://ssd.eff.org/en/glossary/out-band-verification">out-of-band (OOB) channel</a>.</p>
<ul>
<li>Sender and receiver could meet in the real world and verify their respective cryptographic identities by comparing public keys on their screens, or by scanning a QR code. Note, that this scenario requires both parties to trust their hard- and software (e.g. display drivers) to show the right public key or QR code.</li>
</ul>
<p><strong>Threat model:</strong> The adversary controls the network and in particular the channel (or the third party) used to exchange the identities, but does not control the channel used to verify them.</p>
<h2 id="delegated-verification"><a class="header" href="#delegated-verification">Delegated verification</a></h2>
<p>Instead of performing the verification itself, the receiver can also decide to trust another party to verify the sender’s identity for them. There are several variants of this scenario, although they are all based on the principle of delegated verification or delegated trust.</p>
<h3 id="trusted-third-party-verification"><a class="header" href="#trusted-third-party-verification">Trusted third party (verification)</a></h3>
<p>Similar to the use of TTPs as an authenticated channel to exchange identities, a TTP can also be used to verify a cryptographic identity. As with the use of a TTP for the exchange of identities, the cryptographic identity of the TTP has to be known to all users for this approach to work.</p>
<ul>
<li>Many people use their homepages or social media profiles to publish a fingerprint of their cryptographic identity in one or more messaging apps. As long as the receiver can establish an authenticated channel to the TTP hosting the fingerprint, it can verify the identity.</li>
<li>In the context of the WebPKI, when connecting to a web server via HTTPS, the server sends its certificate and provides a certificate chain from the server certificate to a WebPKI root of trust. The client can now verify the chain up to the root of trust. The certificate authorities that sign server certificates in the root of trust thus act as TTPs for verification.</li>
</ul>
<p><strong>Threat model:</strong> The adversary controls the network and in particular the channel (or the third party) used to exchange the identities, but not the third party that facilitates the verification.</p>
<h3 id="cross-signing"><a class="header" href="#cross-signing">Cross-signing</a></h3>
<p>Cross-signing is similar to the use of a TTP for verification, except that the parties that cross-sign a cryptographic identity are regular participants of the messaging system. Cross-signing is often used in addition to other authentication mechanisms.</p>
<ul>
<li>Cross-signing is commonly used if a party has multiple clients, each with its own cryptographic identity. In this case, the cryptographic identity of a new client can be cross-signed by an existing one, allowing other parties that have already verified the identity of the cross-signer to also trust in the new client.</li>
</ul>
<p><strong>Threat model:</strong> The adversary controls the network, but does not control the party cross-signing the cryptographic identity in question. The adversary also cannot compromise parties that are trusted to cross-sign.</p>
<h3 id="web-of-trust"><a class="header" href="#web-of-trust">Web of trust</a></h3>
<p>The <a href="https://en.wikipedia.org/wiki/Web_of_trust">web of trust</a> is a special case of cross-signing, where any party can cross-sign the cryptographic identity of any other party and publish its cross-signature in a publicly accessible directory. A party judging the trustworthiness of a cryptographic identity can base its decision on the quantity and quality of cross-signatures for a given identity, where the quality of the signature is equivalent to the amount of trust placed in the cross-signer.</p>
<p>While other verification approaches have a clear condition under which the receiver will trust the veracity of a sender’s cryptographic identity, this is not necessarily the case with the web of trust. Here, the receiver has to decide to which degree it trusts a certain cryptographic identity depending on who signed a sender’s identity and how much the receiver trust the signers.</p>
<ul>
<li>The web of trust is used in PGP, where parties can upload their signature over other cryptographic identities to a well-known set of public key servers. The receiver can download the sender’s public key and check who has cross-signed it. If the receiver concludes that enough people have signed whom it trusts (and the public keys of whom it has already verified), the receiver can use the sender’s public key for authentication.</li>
</ul>
<p><strong>Threat model:</strong> The verifier has several parties that it trusts to verify other cryptographic identities for them and the identity of which the verifier has indeed verified. The adversary cannot compromise enough trusted parties to pass the threshold required for the verifier to trust that a cryptographic identity is valid.</p>
<h2 id="verifiable-data-structures"><a class="header" href="#verifiable-data-structures">Verifiable data structures</a></h2>
<p><a href="https://transparency.dev/verifiable-data-structures/">Verifiable data structures</a> cannot prevent MITM attacks entirely, but make them harder for an adversary to perform without detection.</p>
<p>A TTP (or any other party that either publishes cryptographic identities or provides delegated verification) can record its actions (either publication or verification of a cryptographic identity) in a verifiable data structure. The data structure allows the TTP to prove to other parties that its records are consistent (i.e. that past records were not altered or deleted) and that individual entries are indeed part of the data structure (proof of inclusion of a given record). The TTP can then regularly publish a <em>view</em> of its current records in which an inclusion proof holds. Consistency is then guaranteed by providing proofs that a view is the successor of previous view.</p>
<p>Parties can now check that their own identity is correct in the view that the TTP presents to them.</p>
<p>Also two communicating parties can include the view they received from the TTP in their messages. If two views differ (and one is not a successor of the other), it is a sign that the TTP has tampered with its records and shown different records to the two parties.</p>
<ul>
<li>Certificate authorities (CAs) in the WebPKI can (and are sometimes required to) use Certificate Transparency to publish the server certificates they sign. Clients can demand from servers to prove that its certificate has been published in the Certificate Transparency log. If a (CA-signed) certificate is used to conduct a MITM attack, there is proof that the CA has either accidentally or intentionally helped facilitate the attack.</li>
</ul>
<p><strong>Threat model:</strong> The adversary can compromise the TTP and actively impersonate a party towards a victim by claiming that one of their own identities is the genuine identity of the victim. However, it will have to show different views to the impersonated party and the victim. If parties exchange their views of the TTP with one-another, the adversary has to decide which party to show which view to avoid detection. If two parties exchange differing views, the adversary is caught.</p>
<h2 id="verification-question"><a class="header" href="#verification-question">Verification question</a></h2>
<p>Similar to an OOB channel, the sender and receiver can use shared information to help gain trust in one another’s cryptographic identity. <a href="https://dl.acm.org/doi/abs/10.1145/1314333.1314340">An adaptation of the socialist millionaire problem</a> allows one party to ask a question and provide the expected answer. The other party learns the question and provides its answer. The protocol then allows the parties to learn both if their replies and their shared cryptographic identities match without leaking their specific answers.</p>
<ul>
<li>The Off-the-Record (OTR) protocol allows for authentication via a verification question as described above to verify cryptographic identities. The initiating user is asked to provide a question and corresponding answer. The responder is then shown the question and also prompted for an answer. If the answers match, the identities are considered verified.</li>
</ul>
<p><strong>Threat model:</strong> The adversary can control the network completely, as long as it doesn’t know the answer to the question.</p>
<h1 id="approaches-used-in-messaging-applications"><a class="header" href="#approaches-used-in-messaging-applications">Approaches used in messaging applications</a></h1>
<p>Different messaging applications make use of one or more of the authentication approaches, sometimes with small variations to the general concepts described above.</p>
<h3 id="multi-client-or-composed-user-identities"><a class="header" href="#multi-client-or-composed-user-identities">Multi-client or composed user identities</a></h3>
<p>Messaging applications often allow the use of multiple clients (e.g. on different devices) by a single user. However, since users are typically interested in authenticating users rather than individual clients, applications have to deal with the challenge of presenting a single user identity despite messages being sent potentially from more than one client.</p>
<p>Multi-client authentication is not covered in the discussion of existing approaches above, because the individual messaging applications have found unique ways of dealing with this problem.</p>
<h2 id="signal"><a class="header" href="#signal">Signal</a></h2>
<p>The Signal app takes the TTP approach to authentication with <a href="https://support.signal.org/hc/en-us/articles/360007060632-What-is-a-safety-number-and-why-do-I-see-that-it-changed-">optional OOB verification by the user</a>. Users can discover other users via the Signal servers. Once a connection is established with another user, the server provides both users with the cryptographic identities of their peers. The same is true if a user joins a group with other users with whom it doesn’t necessarily have a previous connection.</p>
<p>Additionally, users can verify the identity of other users out-of-band, either by comparing a numerical code or by scanning a QR code. Notably, the code presented by the Signal app is not the cryptographic identity of a specific user, but instead a byte string specific to the connection between the users.</p>
<h3 id="multi-client"><a class="header" href="#multi-client">Multi-client</a></h3>
<p>Signal provisions all clients of a user with the same cryptographic identity, thus allowing users to perform OOB verification a single time to verify the cryptographic identity of all of the clients of a given user.</p>
<p>Since all clients have the same identity and thus can’t be told apart cryptographically, there is no way to revoke the individual cryptographic identity of a client. However, client removal is still possible with the assistance of the Signal server, which manages the message queues of individual clients.</p>
<h2 id="whatsapp"><a class="header" href="#whatsapp">WhatsApp</a></h2>
<p>WhatsApp uses the same general approach to authentication as Signal. Cryptographic identities are distributed via the WhatsApp servers, which act as TTPs. Users can additionally verify the safety numbers OOB, with the app providing the ability to scan another user’s safety number via a QR code. However, safety numbers are computed differently than by the Signal app, which is due to WhatsApp’s different approach to multi-client.</p>
<h3 id="multi-client-1"><a class="header" href="#multi-client-1">Multi-client</a></h3>
<p>Even though both applications share the underlying protocol, WhatsApp takes a different approach to multiple clients than Signal. Instead of sharing a cryptographic identity, each client has its own, distinct identity. Consequently, the <a href="https://faq.whatsapp.com/791574747982248/?locale=en_US">safety number</a> for a pair of users is computed from the set of clients of both users. Thus, when comparing safety numbers OOB, users also verify their view of each other’s clients.</p>
<p>If a client is added, WhatsApp takes a <a href="https://engineering.fb.com/2021/07/14/security/whatsapp-multi-device/">cross-signing approach</a> in addition to the TTP approach with optional OOB verification. When adding a new client, an existing client is required to sign the cryptographic identity of the new one. This does not happen automatically but instead requires the user to scan the identity of the new client using the existing one. The signed identity of the new client is then sent to the peers of the user. The user’s peers can thus trust the new client as much as it trusted the existing client. In particular, if user and peer previously verified safety codes OOB, they do not have to do so again after the addition of the new client.</p>
<p>Similarly, the user can revoke its own clients with an existing client authenticating the revocation.</p>
<h2 id="keybase"><a class="header" href="#keybase">Keybase</a></h2>
<p>Keybase keeps a <a href="https://book.keybase.io/docs/teams/sigchain">signature chain</a> as the user’s cryptographic identity. That signature chain contains the identities of all of the users’ clients and can, optionally, include other “proofs of identity”, such as a link to a social media account. This link is verified by the Keybase servers rather than by other end users. The chain can only be extended by the user’s clients. The chain is never shortened and clients are removed by recording the removal in the chain rather than shortening or changing the chain.</p>
<p>Since the chain is distributed by the Keybase servers, the approach is a TTP approach with optional OOB verification and added links to external (non-cryptographic) identities.</p>
<h3 id="multi-client-2"><a class="header" href="#multi-client-2">Multi-client</a></h3>
<p>Each client has its own cryptographic identity. A new client is added to the chain by an existing client upon creation. Similarly, client removals are recorded on the chain by the client performing the removal.</p>
<h2 id="threema"><a class="header" href="#threema">Threema</a></h2>
<p>Threema follows a TTP approach with optional OOB verification (see page 6 on <a href="https://threema.ch/press-files/2_documentation/cryptography_whitepaper.pdf">Threema’s cryptography whitepaper</a>). Threema is special in that it very prominently displays the degree of authentication for a given contact. If the cryptographic identity of a given contact was simply fetched from the Threema server, it shows a single red point. If there is a phone number or email address associated with the contact that is already in the user’s address book, it shows two orange points (this is essentially still relying entirely on the TTP). Finally, if the user has performed an OOB verification, it shows three green points.</p>
<h3 id="multi-client-3"><a class="header" href="#multi-client-3">Multi-client</a></h3>
<p>The multi-client approach taken by Threema is not reflected in the user’s cryptographic identity (see page 20 and following in the whitepaper linked above). There is a primary (mobile) client, with the option to open a secondary client in a browser. That client does not have its own cryptographic identity but instead relays messages through the primary client.</p>
<p>The secondary clients can be managed by the primary client.</p>
<h2 id="pgp"><a class="header" href="#pgp">PGP</a></h2>
<p>PGP follows the web of trust approach with optional OOB verification. As described above, users can use their cryptographic identities to sign those of other users. This usually happens after the user has verified OOB that a given identity indeed belongs to the user in question. A user who has no way to verify an identity OOB can then check the existing signatures on the identity and decide, depending on how much the user trusts the judgment of the signers if the it can trust the identity in question.</p>
<h3 id="multi-client-4"><a class="header" href="#multi-client-4">Multi-client</a></h3>
<p>PGP doesn’t have a notion of clients specifically and instead requires the user to manage its own key material. It is thus possible to either use different identities on different clients or just use the same on all clients. The user is also free to choose if and how to cross-sign the identities or to use a hierarchy of identities.</p>
<h2 id="element"><a class="header" href="#element">Element</a></h2>
<p>Element clients obtain the identity of their peers from their respective home servers, which act as trusted third parties. In addition, Element allows the verification of users OOB either in an interactive process, where users compare a sequence of Emoji in real-time or by comparing the full “session key” (which is presumably the client’s Curve25519 identity key). The former approach has to happen in real-time, which allows Element to only display a short sequence of emoji, while the latter can happen asynchronously.</p>
<h3 id="multi-client-5"><a class="header" href="#multi-client-5">Multi-client</a></h3>
<p>Element clients have distinct identity keys. When a new client is created, it <a href="https://element.io/enterprise/device-verification">can be cross-signed</a> by an existing client. Thus, when performing the OOB verification process described above, all cross-signed clients are verified at once. Interestingly, after an OOB verification took place, new clients have to be verified even after they were cross-signed by an existing client. See also the Matrix specification for <a href="https://spec.matrix.org/v1.3/client-server-api/#cross-signing">cross-signing</a>.</p>
<p>Peers keep track of a user’s clients (<em>devices</em> in the Matrix specification) by periodically checking the user’s list of devices. If a user changes its list of devices, e.g. by removing a device, its peers will learn of this when they next synchronize with their respective homeservers.</p>
<h2 id="imessage"><a class="header" href="#imessage">iMessage</a></h2>
<p>iMessage <a href="https://support.apple.com/guide/security/how-imessage-sends-and-receives-messages-sec70e68c949/web">purely relies on the TTP approach</a>, where Apple distributes the cryptographic identities of individual parties to conversation partners. There is no way for parties to verify their peers’ public keys OOB.</p>
<h3 id="multi-client-6"><a class="header" href="#multi-client-6">Multi-client</a></h3>
<p>iMessage clients have their own cryptographic identity and Apple automatically distributes keys of new clients, as well as changes to a user’s client list to a user’s contacts.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>

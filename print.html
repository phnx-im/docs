<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Docs</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="status.html">Status</a></li><li class="chapter-item expanded "><a href="functional_requirements.html"><strong aria-hidden="true">1.</strong> Functional Requirements</a></li><li class="chapter-item expanded "><a href="modularization.html"><strong aria-hidden="true">2.</strong> Modularization</a></li><li class="chapter-item expanded "><a href="performance_goals.html"><strong aria-hidden="true">3.</strong> Performance Goals</a></li><li class="chapter-item expanded "><a href="threat_model.html"><strong aria-hidden="true">4.</strong> Threat Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threat_model/methodology.html"><strong aria-hidden="true">4.1.</strong> Methodology</a></li><li class="chapter-item expanded "><a href="threat_model/security_assumptions.html"><strong aria-hidden="true">4.2.</strong> Security Assumptions</a></li><li class="chapter-item expanded "><a href="threat_model/application_assets.html"><strong aria-hidden="true">4.3.</strong> Application Assets</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements.html"><strong aria-hidden="true">4.4.</strong> Security Requirements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="threat_model/security_requirements/operators.html"><strong aria-hidden="true">4.4.1.</strong> Operators</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/public.html"><strong aria-hidden="true">4.4.2.</strong> Public</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/users.html"><strong aria-hidden="true">4.4.3.</strong> Users</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/clients.html"><strong aria-hidden="true">4.4.4.</strong> Clients</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/federated_homeservers.html"><strong aria-hidden="true">4.4.5.</strong> Federated Homeservers</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/federated_users.html"><strong aria-hidden="true">4.4.6.</strong> Federated Users</a></li><li class="chapter-item expanded "><a href="threat_model/security_requirements/federated_clients.html"><strong aria-hidden="true">4.4.7.</strong> Federated Clients</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="cryptographic_primitives.html"><strong aria-hidden="true">5.</strong> Cryptographic Primitives and Schemes</a></li><li class="chapter-item expanded "><a href="spec.html"><strong aria-hidden="true">6.</strong> Specification (Draft)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="spec/authentication_service.html"><strong aria-hidden="true">6.1.</strong> Work in progress: Authentication service</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="spec/authentication_service/credentials.html"><strong aria-hidden="true">6.1.1.</strong> Credentials</a></li><li class="chapter-item expanded "><a href="spec/authentication_service/evolving_identities.html"><strong aria-hidden="true">6.1.2.</strong> Evolving Identities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="spec/authentication_service/new_device_flow.html"><strong aria-hidden="true">6.1.2.1.</strong> Adding new devices</a></li></ol></li><li class="chapter-item expanded "><a href="spec/authentication_service/connection_establishment.html"><strong aria-hidden="true">6.1.3.</strong> Discovery and connection esablishment</a></li></ol></li><li class="chapter-item expanded "><a href="spec/delivery_service.html"><strong aria-hidden="true">6.2.</strong> Delivery service</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="spec/delivery_service/group_state_encryption.html"><strong aria-hidden="true">6.2.1.</strong> Group state encryption</a></li><li class="chapter-item expanded "><a href="spec/delivery_service/broken_state_detection.html"><strong aria-hidden="true">6.2.2.</strong> Broken state detection</a></li></ol></li><li class="chapter-item expanded "><a href="spec/queuing_service.html"><strong aria-hidden="true">6.3.</strong> Queuing service</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="spec/queuing_service/queue_encryption.html"><strong aria-hidden="true">6.3.1.</strong> Queue encryption</a></li><li class="chapter-item expanded "><a href="spec/queuing_service/keypackage_publication.html"><strong aria-hidden="true">6.3.2.</strong> KeyPackage publication</a></li></ol></li><li class="chapter-item expanded "><a href="spec/clients.html"><strong aria-hidden="true">6.4.</strong> Work in progress: Clients</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="spec/clients/client_sync.html"><strong aria-hidden="true">6.4.1.</strong> Client synchronization</a></li></ol></li><li class="chapter-item expanded "><a href="spec/future_work.html"><strong aria-hidden="true">6.5.</strong> Future work</a></li><li class="chapter-item expanded "><a href="spec/glossary.html"><strong aria-hidden="true">6.6.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><a href="authentication_systems.html"><strong aria-hidden="true">7.</strong> Authentication in messaging applications</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>This book contains design considerations and documentation for an infrastructure that allows clients to exchange messages via the Messaging Layer Security (MLS) protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-mls-infrastructure-project-status"><a class="header" href="#open-mls-infrastructure-project-status">Open MLS Infrastructure Project Status</a></h1>
<h2 id="update-1-oct-05-2022"><a class="header" href="#update-1-oct-05-2022">Update 1, Oct. 05 2022</a></h2>
<p>The short chapter on <a href="./authentication_systems.html#">authentication systems</a> we add to the book today provides an overview over existing approaches to authentication in secure messaging applications. The report is based on testing, as well as public documentation of the individual applications.</p>
<h2 id="update-0-july-22-2022"><a class="header" href="#update-0-july-22-2022">Update 0, July 22 2022</a></h2>
<p>Today, we publish a <a href="./threat_model.html">threat model</a> for an abstract homeserver that aims fulfills the functional requirements. The threat model also contains privacy and security requirements. This is a first iteration and just like the functional requirements, we expect this to be a living document that grows as we move forward with this project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-requirements"><a class="header" href="#functional-requirements">Functional Requirements</a></h1>
<p>This section describes the functional requirements of a homeserver. Before we detail the individual requirements, we first introduce the different roles that interact with the system.</p>
<p>Note that while the homeserver should ultimately provide the functionality described, the entity in the given role might have to keep state and perform protocol actions to interact with the homeserver.</p>
<h2 id="roles"><a class="header" href="#roles">Roles</a></h2>
<p>A large part of the infrastructure consists of the homeserver, which is operated by the <em>operator</em>. The homeserver exposes most of its API endpoints to <em>clients</em> of <em>users</em> that are registered with the homeserver. The remaining endpoints of the homeserver's API are accessible to <em>the network</em>, as well as <em>federated homeservers</em>. Individuals that are registered with other homeservers are <em>federated users</em> who run <em>federated clients</em>.</p>
<h3 id="operator"><a class="header" href="#operator">Operator</a></h3>
<p>The entity that operates a homeserver. It is assumed to have control over the domain they configure as the homeserver's <em>home domain</em>.</p>
<h3 id="the-network"><a class="header" href="#the-network">The Network</a></h3>
<p>The network includes all entities that have access to the port exposing the homeserver endpoints.</p>
<h3 id="users"><a class="header" href="#users">Users</a></h3>
<p>Users are individuals that have registered as users with the homeserver and that are associated with a unique and immutable <em>user id</em> scoped by the homeserver's home domain. Each user also has a unique <em>user name</em>. Registered users can have one or more registered clients.</p>
<p>The user is ultimately the entity that other users authenticate before starting a conversation.</p>
<p>In the context of federation, users of a given homeserver will sometimes be called <em>local</em> users as opposed to <em>federated</em> users.</p>
<h3 id="clients"><a class="header" href="#clients">Clients</a></h3>
<p>A client is a piece of software associated with and run by a user. The client holds the key material used to authenticate (and thus the user) to other clients and their users. Each client is associated with a <em>client id</em> that is scoped by its user's ID.</p>
<h3 id="federated-homeservers"><a class="header" href="#federated-homeservers">Federated Homeservers</a></h3>
<p>Other instances of the homeserver that are reachable via the network, where both the local and the federated homeserver have been configured to allow mutual federation. Each is assumed to be configured with its own home domain.</p>
<h3 id="federated-users"><a class="header" href="#federated-users">Federated Users</a></h3>
<p>Individuals that have registered with a federated homeserver in the same way as users have with the local one.</p>
<h3 id="federated-clients"><a class="header" href="#federated-clients">Federated Clients</a></h3>
<p>Federated clients are clients which are run by federated users. They are regular clients that are associated with a federated user instead of a local user.</p>
<h2 id="functional-requirements-for-each-role"><a class="header" href="#functional-requirements-for-each-role">Functional Requirements for each Role</a></h2>
<h3 id="functional-requirements-for-homeserver-operators"><a class="header" href="#functional-requirements-for-homeserver-operators">Functional Requirements for Homeserver Operators</a></h3>
<ul>
<li>Homeserver management: Operators MUST be able to configure the homeserver and manage its users locally.</li>
<li>Homedomain setup: Operators MUST be able to set the home domain of the homeserver during setup.</li>
<li>Federation configuration: Operators MUST be able to configure federation: Either by allowlisting other homeservers by their home domain, or by allowing open federation except for a blocklist of home domains for homeservers with which federation is not desired.</li>
</ul>
<h3 id="functional-requirements-for-the-network"><a class="header" href="#functional-requirements-for-the-network">Functional Requirements for the Network</a></h3>
<ul>
<li>User registration: Entities in the public network MUST be able to register a new user.</li>
</ul>
<h3 id="functional-requirements-for-users"><a class="header" href="#functional-requirements-for-users">Functional Requirements for Users</a></h3>
<p>The distinction between users and their clients is difficult because the user will perform most of their interactions with the homeserver through the client. The following is a list of operations performed through the client, which concern the user as their own entity and might thus also affect all of their clients.</p>
<ul>
<li>Client management: Users MUST be able to manage clients (this includes updates to client key material).</li>
<li>Account reset: Users SHOULD be able to reset the account. Members of groups the user is in MUST be notified of the reset.</li>
<li>User name change: Users MUST be able to change their user name. Members of groups the user is in MUST be notified of the new name.</li>
<li>User discovery: Users MUST be able to discover other users.</li>
<li>Connection establishment: Users MUST be able to initialize a connection with previously discovered users (via a two-user MLS group, implies retrieval of <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#section-11">KeyPackages</a> of all of the other user's clients).</li>
<li>Connection rejection: Users MUST be able to accept or reject a connection initialized by another (local or federated) user. The sender of the connection request SHOULD be notified of the acceptance or rejection of the request.</li>
<li>Connection management: Users SHOULD be able to block other (local or federated) users s.t. they don't receive messages from that user anymore. Users SHOULD be able to unblock previously blocked users.</li>
<li>Account deletion: Users MUST be able to delete their account. Members of groups the user is in MUST be notified of the deletion.</li>
</ul>
<h3 id="functional-requirements-for-clients"><a class="header" href="#functional-requirements-for-clients">Functional Requirements for Clients</a></h3>
<p>MLS natively provides a number of group management mechanics such as membership management. The homeserver's task is thus to fulfill the role of an MLS <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#section-4">Delivery Service</a>.</p>
<ul>
<li>Group creation: Clients MUST be able to initialize an MLS group.</li>
<li>Group deletion: Clients MUST be able to delete an MLS group.</li>
<li>Message delivery: Clients MUST be able to asynchronously send <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#section-7">MLS messages</a> to all members of an MLS group that it is a member of (this implies the &quot;filtering server&quot; role specified by the <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#section-4.3">&quot;delivery of messages&quot;</a> requirement of the MLS architecture document). If a given group member has provided the homeserver with a notification for this group, the homeserver MUST attach the notification policy to the message when delivering it. If a group member is a federated client, the homeserver MUST forward the message to the federated homeserver for delivery.</li>
<li>Message queuing: The homeserver MUST store messages sent to a client either by itself or forwarded by a federated homeserver while the client is offline.</li>
<li>Message notifications: Clients MAY provide the homeserver with a means to notify them when a new message is queued, as well as a default notification policy. If the client has provided the homeserver with such a means and corresponding policy, the homeserver MUST notify the client according to either the policy attached to the message, or, if none was attached, according to the default policy.</li>
<li>KeyPackage retrieval: Clients MUST be able to retrieve <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#section-11">KeyPackages</a> for clients of users with a previously established connection (this implies the <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#name-key-storage">&quot;key storage&quot;</a> requirement). As long as there is more than one KeyPackage, the server MUST delete the KeyPackage after it was provided to a (local or federated) client.</li>
<li>Welcome message delivery: Clients MUST be able to send <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#section-13.4.3.1">Welcome</a> messages to clients of users with a previously established connection. If the client has provided the homeserver with a means of notification (and default notification policy), the homeserver MUST notify the client according to the default policy.</li>
<li>Message retrieval: Clients MUST be able to fetch messages queued by the homeserver.</li>
<li>Client authentication: Clients MUST be able to verify the authenticity of MLS leaf <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-credentials">Credentials</a> of clients with which it shares a group (this implies at least partially fulfilling the <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#name-authentication-service">Authentication Service</a> role).</li>
<li>KeyPackage publishing: Clients MUST be able to publish <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#section-11">KeyPackages</a> (this implies the <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#name-key-retrieval">&quot;key retrieval&quot;</a> requirement). When a client publishes new KeyPackages, the homeserver MUST delete all remaining previously uploaded KeyPackages of that client.</li>
<li>Notification configuration: Clients SHOULD be able to configure notification settings of groups of which it is a member.</li>
</ul>
<h3 id="functional-requirements-for-federated-homeservers"><a class="header" href="#functional-requirements-for-federated-homeservers">Functional Requirements for Federated Homeservers</a></h3>
<ul>
<li>Federated message delivery: Federated homeservers MUST be able to send messages for delivery to one of the homeserver's clients.</li>
</ul>
<h3 id="functional-requirements-for-federated-users"><a class="header" href="#functional-requirements-for-federated-users">Functional Requirements for Federated Users</a></h3>
<p>The functional requirements <em>user discovery</em> and <em>connection establishment</em> for local users also apply for federated users.</p>
<h3 id="functional-requirements-for-federated-clients"><a class="header" href="#functional-requirements-for-federated-clients">Functional Requirements for Federated Clients</a></h3>
<p>The functional requirements <em>message delivery</em>, <em>KeyPackage retrieval</em>, <em>welcome message delivery</em>, <em>client authentication</em> and <em>notification configuration</em> for local clients also apply for federated clients.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modularization-and-architecture-overview"><a class="header" href="#modularization-and-architecture-overview">Modularization and Architecture Overview</a></h1>
<p>The requirements sketched above provide a good distribution of services across modules within the homeserver. Here, we provide a list of modules, as well as the functionality we expect them to provide to users and their clients.</p>
<h2 id="modules"><a class="header" href="#modules">Modules</a></h2>
<ul>
<li>Delivery service:
<ul>
<li>Initial creation of a group and management of the corresponding state (including addition and removal of members)</li>
<li>Message delivery to members of a given group</li>
</ul>
</li>
<li>Authentication service:
<ul>
<li>Registration of new users</li>
<li>Addition and removal of clients of a given user</li>
<li>User discovery</li>
<li>Authentication of users through their clients</li>
</ul>
</li>
<li>Queuing service:
<ul>
<li>Creation of queues for clients</li>
<li>Enqueuing of messages by the delivery service</li>
<li>Dequeuing of messages by the client owning the queue</li>
</ul>
</li>
<li>KeyPackage service:
<ul>
<li>Upload of KeyPackages</li>
<li>Retrieval of KeyPackages for a given client or user</li>
</ul>
</li>
</ul>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>The following shows a simplified interface between client and homeserver. Note, that for some of the security requirements (which we will detail in a later report), we might add one or more additional modules. For example, we will likely add a module that provides DDoS protection.</p>
<p><img src="images/homeserver_interface.png" alt="Simplified interface for client ↔ backend communication." /></p>
<p>Simplified interface for client ↔ backend communication.</p>
<h2 id="federated-architecture"><a class="header" href="#federated-architecture">Federated Architecture</a></h2>
<p>We will later generalize the above architecture to work in a federated setting. The general principle here is that individual clients only ever communicate through their own homeserver, so if a client’s query is w.r.t. another client, user or group that exists on another backend, that query will be forwarded accordingly. The target client/user/group’s homeserver is implicit in the GroupId/UserId/QueueId in question.</p>
<p><img src="images/cross_homeserver_flow.png" alt="Sketch of a message delivery from one client across two homeserver. Alice contacts her Delivery Service, which in turn contacts the Queuing Service of Backend 2. Finally, Bob can retrieve the message from his homeserver by contacting the Queuing Service." /></p>
<p>Sketch of a message delivery from one client across two homeserver. Alice contacts her Delivery Service, which in turn contacts the Queuing Service of Backend 2. Finally, Bob can retrieve the message from his homeserver by contacting the Queuing Service.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-goals"><a class="header" href="#performance-goals">Performance goals</a></h1>
<p>The goal of the homeserver(s) is to facilitate messaging for consumers in general and in particular consumers with resource constrained devices such as smartphones running. Despite the advances in battery capacity, memory and computational performance in modern smartphones, consumers should still be able to communicate with the infrastructure without incurring disproportionate resource consumption. Additionally applications should be able to use the infrastructure without requiring exceptions to the restrictions that platforms running on modern smartphones (Android, iOS) impose on applications such as limited computation time when running in the background.</p>
<p>Similarly, homeserver operators should be able to run their servers without a significant overhead in costs due to computation, memory or persistent storage.</p>
<p>Quantifying performance goals is hard, since the hardware differs significantly across vendors. However, since cryptography is going to make up the largest consumer of computation time, as well as memory and persistent storage, we are going to use asymmetric cryptographic operations (public key encryption, signatures) as unit of measurement for computational overhead and number of keys that need to be stored as unit of measurement for memory and persistent storage overhead. This has the added advantage that we can later estimate the additional overhead in case of adoption of a Post-Quantum secure scheme with significantly larger key sizes.</p>
<h2 id="client-queries"><a class="header" href="#client-queries">Client Queries</a></h2>
<ul>
<li>Network overhead: Clients should be able to perform the most commonly used queries (i.e. send a message to a group or retrieve messages from their queue) with a single round-trip. In particular, it should be possible to request own messages in batch, although the service might limit the size each batch of messages retrieved at a time, leading to additional round trips.</li>
<li>Computational overhead: The estimated computational cost for a given query heavily depends on the type of query. Let n be the number of member in a given group.
<ul>
<li>Simple (application) message to a group: One asymmetric operation for both sender and receiver</li>
<li>Message updating encryption key material: Less than 3log(n) asymmetric operations for the sender and less than log(n)</li>
<li>Message updating authentication key material of adding/removing a group member: Same as updating encryption key material plus &lt;10 asymmetric operations per joining client</li>
<li>Joining a new group: between 5n and 10n asymmetric operations</li>
</ul>
</li>
</ul>
<p>Performance constraints are especially important if the respective operations are potentially performed in the background, i.e. when a user is not currently interacting with the client.</p>
<h2 id="homeserver-processing"><a class="header" href="#homeserver-processing">Homeserver Processing</a></h2>
<ul>
<li>Network overhead: Homeservers should typically respond to one message with one response, although fan-out of a message can result in additional messages sent over the network in a federated setting. Note, that disproportionate amplification of network traffic (i.e. one client request causing a number of server requests) will be mitigated by rate limiting measures such as traditional IP-based rate limiting and schemes such as Privacy Pass.</li>
<li>Computational overhead: With the exception of the group joining cost, the computational cost of the server will be roughly equivalent to that of a client processing a given message.</li>
<li>IO overhead: A query from a client should result in at most one read and one write operation from/to the homeserver’s database, although we expect caching to reduce the number of reads significantly.</li>
</ul>
<h2 id="additional-overhead-due-to-rate-limiting"><a class="header" href="#additional-overhead-due-to-rate-limiting">Additional Overhead due to Rate-Limiting</a></h2>
<p>More sophisticated rate limiting measures, such as the Privacy Pass protocol might create additional overhead, such as an occasional additional round-trip and asymmetric operation to retrieve an access token from the homeserver. We estimate the required frequency of this kind of operation to be at most once per day.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threat-model"><a class="header" href="#threat-model">Threat model</a></h1>
<p>This document contains a threat model for an MLS homeserver. For now, this threat model is based solely on its functional requirements. As we build the specification of the homeserver, we will update this document to consider any additional assets.</p>
<h2 id="functional-requirements-1"><a class="header" href="#functional-requirements-1">Functional requirements</a></h2>
<p>The homeserver is expected to fulfill the functional requirements described <a href="./functional_requirements.html">here</a> and to interface with parties fulfilling the roles outlined in that document.</p>
<h2 id="mls-as-underlying-protocol"><a class="header" href="#mls-as-underlying-protocol">MLS as underlying protocol</a></h2>
<p>The homeserver facilitates communication between clients via the Messaging Layer Security (MLS) protocol, which already provides a number of <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#name-intended-security-guarantee">security guarantees</a> which we do not describe here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threat-model-methodology"><a class="header" href="#threat-model-methodology">Threat model methodology</a></h1>
<p>We describe our threat model by roughly following the STRIDE framework as outlined <a href="https://www.securesoftware.nl/resources/FrameworkSecureSoftware_v1.pdf">here</a>. However, we modify the methodology slightly to fit use-case.</p>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>The &quot;Authentication&quot; property as listed in the STRIDE model can apply to multiple entities in a given operation provided by the homeserver. For example, the <em>message delivery</em> action described in the <a href="threat_model/../functional_requirements.html">functional requirements</a> involves the client requesting that the homeserver deliver the message, the homeserver receiving and processing the request, a potential federated homeserver that stores and forwards the request and finally the user receiving the message on the other end.</p>
<p>We thus have three kinds of authentication rather than just one: Client to server (C2S), server to server (S2S) and client to client (C2C), all of which we consider as sub-properties of the authentication property of the STRIDE model.</p>
<h2 id="spam-reduction"><a class="header" href="#spam-reduction">Spam reduction</a></h2>
<p>Spam (outside of its potential for a denial-of-service attack on the homeserver) is a general risk for a messaging service. We talk about spam reduction rather than spam prevention, because we don't believe spam is a problem that can be avoided entirely in a privacy-preserving messenger and instead aim to reduce it to a minimum.</p>
<p>In the context of our threat model, we consider spam potential an additional security risk for every action that leads to messages being sent to users or that otherwise alerts the user, e.g. by triggering a notification. This is reflected by adding the security property <em>spam reduction</em> to the existing STRIDE properties.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-assumptions"><a class="header" href="#security-assumptions">Security assumptions</a></h1>
<p>The operator of a homeserver can leverage its conrol over the homeserver to influence if and how the homeserver serves its users. While the goal of the protocol should be to reduce the amount of control the operator has, there are a few assumptions that need to be made.</p>
<h2 id="operators-are-trusted-not-to-spam-users"><a class="header" href="#operators-are-trusted-not-to-spam-users">Operators are trusted not to spam users</a></h2>
<p>Homeserver operators can circumvent any server-side spam reduction mechanisms and will thus be able to send excessive amounts of messages to a user and their clients (or notifications if the user provides the homeserver with a means to notify them). While the client can impose its own spam reduction mechanisms that the homeserver operator can't circumvent, they will likely also impede the usability of the client.</p>
<h2 id="operators-are-trusted-not-to-deny-services-to-individual-users"><a class="header" href="#operators-are-trusted-not-to-deny-services-to-individual-users">Operators are trusted not to deny services to individual users</a></h2>
<p>The homeserver operator can control which user the homeserver provides its services to and to which ones it doesn't. Metadata minimalism already mitigates this problem to a certain degree, because in most cases, the operator shouldn't know who makes a certain request. However, some actions such as client management or user name changes require explicit authentication, allowing the operator to lock out users in a targeted way. Similarly, the operator can simply delete records of a specific user from the database, or deny a given user the ability to publish KeyPackages.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="application-assets"><a class="header" href="#application-assets">Application assets</a></h1>
<p>The homeserver will have to perform all actions listed for the individual roles in the <a href="threat_model/./functional_requirements.html">functional requirements section</a>.</p>
<p>To fulfill these requirements, the homeserver will keep the following state (information assets in STRIDE terminology). Each piece of state is annotated by the actions involved in its lifecycle.</p>
<ul>
<li>Group state (for message delivery, including associated metadata such as group membership lists)
<ul>
<li>Create: Group creation</li>
<li>Read, Update: Message delivery (with inline MLS group management)</li>
<li>Delete: Group deletion</li>
</ul>
</li>
<li><a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-key-packages">KeyPackages</a> for retrieval by clients
<ul>
<li>Create/Update/Delete: KeyPackage publishing (publication of new KeyPackages implies deletion of old ones)</li>
<li>Read/Delete: KeyPackage retrieval (reading implies deletion, except for <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-keypackage-reuse">KeyPackages of last resort</a>)</li>
</ul>
</li>
<li>Authentication key material of users and their clients
<ul>
<li>Create/Update/Delete: Client management</li>
<li>Update: Account reset</li>
<li>Delete: Account deletion</li>
<li>Read: Client authentication</li>
</ul>
</li>
<li>User names
<ul>
<li>Create: User registration</li>
<li>Update: User name change</li>
<li>Read: User discovery</li>
<li>Delete: Account deletion</li>
</ul>
</li>
</ul>
<p>This section will be extended with more information assets as the specification is written.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-requirements"><a class="header" href="#security-requirements">Security requirements</a></h1>
<p>This section iterates over each role and analyses each action as described in the <a href="threat_model/./../methodology.html">Methodology</a> section.</p>
<p>In addition to any specific security requirements listed in the individual actions, the following general security requirements must hold.</p>
<h2 id="basic-confidentiality-and-authentication"><a class="header" href="#basic-confidentiality-and-authentication">Basic confidentiality and authentication</a></h2>
<p>All actions performed via the network (which includes all actions with the possible exception those of the operator, which may be local, command-line based actions) MUST use be performed through a unilaterally authenticated TLS 1.3 connection using the home domain of the homeserver.</p>
<h2 id="metadata-minimalism"><a class="header" href="#metadata-minimalism">Metadata minimalism</a></h2>
<p>Metadata that is not required to provide functionality at a later point in time MUST be deleted immediately. Similarly, all metadata that is not required to be stored in the clear MUST be stored encrypted-at-rest.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>The actions by the operator only involve the operator and the homeserver. They thus don't involve other authentication beyond the homeserver authenticating the operator.</p>
<p>Since operators are trusted not to spam their users as per <a href="threat_model/security_requirements/../security_assumptions.html">security assumptions</a>, spam prevention will not be listed for operator actions.</p>
<h2 id="homeserver-management"><a class="header" href="#homeserver-management">Homeserver management</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Only operators can perform management actions</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must perform checks to ensure the configuration is valid</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. There is only one homeserver operator</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk. Homeserver management actions are not confidential</td><td></td></tr>
<tr><td>Availability</td><td>Operators should always be able to perform management actions</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. There is only one homeserver operator role</td><td></td></tr>
</tbody></table>
</div>
<h2 id="homeserver-setup"><a class="header" href="#homeserver-setup">Homeserver setup</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Not a risk. The entity setting up the server can only be the operator</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must check if the homeserver domain is a FQDN at startup</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. At the time of setup, identities don't exist yet</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk. The home domain is public</td><td></td></tr>
<tr><td>Availability</td><td>This is a setup action. The homeserver is not running at that time</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. Setup is done by a single entity.</td><td></td></tr>
</tbody></table>
</div>
<h2 id="federation-configuration"><a class="header" href="#federation-configuration">Federation configuration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Only administrators can configure federation</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. Operators are responsible for checking the validity of the configuration</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. There is only one homeserver operator</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk. Federation configuration actions are not confidential</td><td></td></tr>
<tr><td>Availability</td><td>Operators should always be able to manage homeserver federation</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. There is only one homeserver operator role</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="public"><a class="header" href="#public">Public</a></h1>
<h2 id="user-registration"><a class="header" href="#user-registration">User registration</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Not a risk. Registration is publicly accessible</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must perform checks to ensure the user name entered is valid as per specification</td><td></td></tr>
<tr><td>Non-repudiation</td><td>The user or its client must prove possession of authentication key material</td><td></td></tr>
<tr><td>Confidentiality</td><td>No requirements besides the <a href="threat_model/security_requirements/../security_requirements.html">general confidentiality requirements</a></td><td></td></tr>
<tr><td>Availability</td><td>User registration MAY be restricted when the homeserver has limited resources</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. No authorization required for registration</td><td></td></tr>
<tr><td>Spam prevention</td><td>To mitigate spam attacks downstream of user registration, the homeserver MAY restrict user registration</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="users-1"><a class="header" href="#users-1">Users</a></h1>
<p>TODO: Maybe note somewhere generally how notifications, or more generally client-to-client messages must be authenticated? This seems to repeat here and in the client's section.</p>
<h2 id="client-management"><a class="header" href="#client-management">Client management</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication (C2S)</td><td>Users can only manage their own clients</td><td></td></tr>
<tr><td>Authentication (C2C)</td><td>The user's contacts (local and federated) must be able to authenticate the user's actions end-to-end</td><td></td></tr>
<tr><td>Authentication (S2S)</td><td>A federated homeserver forwarding a notification must be able to authenticate the users's homeserver as origin</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. Users are responsible for the integrity of their own clients</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Other clients of the user must be able to determine which client performed the action</td><td></td></tr>
<tr><td></td><td>The user's contacts must be notified of the action</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk. A user's client management is considered public</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to manage their own clients</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. The user can manage clients through any of their clients</td><td></td></tr>
<tr><td>Spam prevention</td><td>Client management actions should be limited, as they are message sending</td><td></td></tr>
</tbody></table>
</div>
<h2 id="account-reset"><a class="header" href="#account-reset">Account reset</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Users can only reset their own accounts</td><td></td></tr>
<tr><td>Authentication (C2C)</td><td>The user's contacts (local and federated) must be able to authenticate the user's actions end-to-end</td><td></td></tr>
<tr><td>Authentication (S2S)</td><td>A federated homeserver forwarding a notification must be able to authenticate the users's homeserver as origin</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. A reset replaces all user data except the user name</td><td></td></tr>
<tr><td>Non-repudiation</td><td>The users contacts must be notified of the user's account reset</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk. No confidential user data is transmitted during an account reset</td><td></td></tr>
<tr><td>Availability</td><td>Users should be able to reset their own account once every month</td><td>TODO: Is this the time frame we want?</td></tr>
<tr><td>Authorization</td><td>Not a risk. The user is the only entity that can perform this action</td><td></td></tr>
<tr><td>Spam prevention</td><td>The homeserver must limit the number of account resets, as they are message sending</td><td></td></tr>
</tbody></table>
</div>
<h2 id="user-name-change"><a class="header" href="#user-name-change">User name change</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Users can only change their own user name</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must ensure the new user name is valid</td><td>(see user registration)</td></tr>
<tr><td>Non-repudiation</td><td>The users contacts must be notified of the user's user name change</td><td></td></tr>
<tr><td>Confidentiality</td><td>The new user name must be communicated to contacts end-to-end encrypted</td><td></td></tr>
<tr><td>Availability</td><td>Users should be able to change their user name once every month</td><td>TODO: Is this the time frame we want?</td></tr>
<tr><td>Authorization</td><td>Not a risk. The user is the only entity that can perform this action</td><td></td></tr>
<tr><td>Spam prevention</td><td>The homeserver must limit the number of user name changes, as they are message sending</td><td></td></tr>
</tbody></table>
</div>
<h2 id="user-discovery"><a class="header" href="#user-discovery">User discovery</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>All registered users should be able to discover other users by their full user name</td><td></td></tr>
<tr><td></td><td>Users must be able to authenticate any user information in an end-to-end way</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. End-to-end authentication implies integrity of the data</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. Users must be able to discover other users anonymously</td><td></td></tr>
<tr><td>Confidentiality</td><td>The user must be able to perform discovery anonymously</td><td></td></tr>
<tr><td></td><td>Users should only be able to discover a limited number of users every day</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to discover users with the given confidentiality restrictions</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to discover other users</td><td></td></tr>
<tr><td>Spam prevention</td><td>Not a risk. Discovering a user should not be message sending</td><td></td></tr>
</tbody></table>
</div>
<h2 id="connection-establishment"><a class="header" href="#connection-establishment">Connection establishment</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>All registered users should be able to establish connections to other users</td><td></td></tr>
<tr><td></td><td>The establishing user must be able to authenticate the target user</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. Authentication implies integrity of the connection request</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. Users must be able to establish connections anonymously</td><td></td></tr>
<tr><td>Confidentiality</td><td>The user must be able to establish connections anonymously w.r.t. the homeserver</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to establish connections (limited by anti-spam measures)</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to establish connections</td><td></td></tr>
<tr><td>Spam prevention</td><td>High spam risk. Connection establishments are message sending must be limited per user</td><td></td></tr>
</tbody></table>
</div>
<h2 id="connection-rejection"><a class="header" href="#connection-rejection">Connection rejection</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>All registered users should be able to accept/reject incoming connections requests</td><td></td></tr>
<tr><td></td><td>The accepting/rejecting user must be able to authenticate the requesting user</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. Authentication implies integrity of the connection request</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk as long as connection requests can be authenticated by the receiving user</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk as long as transport encryption and metadata minimalism are upheld</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to accept or reject connections</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to accept/reject connections</td><td></td></tr>
<tr><td>Spam prevention</td><td>Connection accepts/rejects are message sending and thus have to be limited</td><td>TODO: Is this really message sending?</td></tr>
</tbody></table>
</div>
<h2 id="connection-management"><a class="header" href="#connection-management">Connection management</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>All registered users should be able to manage their existing connections</td><td></td></tr>
<tr><td></td><td>Each user should only be able to manage their own connections</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk. Clients are responsible for their own list of connections</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. Connection management does not need to be logged</td><td></td></tr>
<tr><td>Confidentiality</td><td>The homeserver should not learn which connections a user has</td><td></td></tr>
<tr><td></td><td>The homeserver should not learn which users a user has blocked</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to manage their own connections</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to accept/reject (their own) connections</td><td></td></tr>
<tr><td>Spam prevention</td><td>Connection management is message sending and thus has to be limited</td><td>TODO: Is this really message sending?</td></tr>
</tbody></table>
</div>
<h2 id="account-deletion"><a class="header" href="#account-deletion">Account deletion</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>All registered users should be able to delete their won account</td><td></td></tr>
<tr><td></td><td>Each user should only be able to delete their own account</td><td></td></tr>
<tr><td>Integrity</td><td>Not a risk, as there should be no data left after deletion</td><td></td></tr>
<tr><td>Non-repudiation</td><td>Not a risk. Account deletion should not be logged</td><td></td></tr>
<tr><td>Confidentiality</td><td>Not a risk as long as transport encryption and metadata mimimalism hold</td><td></td></tr>
<tr><td></td><td>In particular, all metadata regarding the deleted account should be deleted</td><td></td></tr>
<tr><td>Availability</td><td>Users should always be able to delete their own account</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to delete (their own) account</td><td></td></tr>
<tr><td>Spam prevention</td><td>Account deletion is message sending and thus has to be limited</td><td>TODO: Is this really message sending?</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="clients-1"><a class="header" href="#clients-1">Clients</a></h1>
<p>TODO: Add note on group integrity validation and why it's only possible to a certain extent.
TODO: Restructure with C2S, S2S and C2C authentication in mind.</p>
<h2 id="group-creation"><a class="header" href="#group-creation">Group creation</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Only clients of local users can create new groups</td><td></td></tr>
<tr><td></td><td>The group creator has to be able to authenticate itself as the only member of the group</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must perform checks to ensure the group state is valid</td><td>Only possible to a certain extent</td></tr>
<tr><td>Non-repudiation</td><td>Not a risk as long as the authentication requirements hold.</td><td></td></tr>
<tr><td>Confidentiality</td><td>The homeserver must not learn the identity of the group creator</td><td>Authentication can be done pseudonymously</td></tr>
<tr><td>Availability</td><td>Users should always be able to create new groups (limited by anti-spam measures)</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All users should be able to create groups</td><td></td></tr>
<tr><td>Spam prevention</td><td>The homeserver must limit the number of groups created by a given user</td><td></td></tr>
</tbody></table>
</div>
<h2 id="message-delivery"><a class="header" href="#message-delivery">Message delivery</a></h2>
<div class="table-wrapper"><table><thead><tr><th>STRIDE property</th><th>Requirement</th><th>Remark</th></tr></thead><tbody>
<tr><td>Authentication</td><td>Only local or federated clients can send messages</td><td></td></tr>
<tr><td></td><td>Only members of a given group can send messages to that group</td><td></td></tr>
<tr><td></td><td>Members must not be able to send messages on behalf of other members</td><td></td></tr>
<tr><td>Integrity</td><td>The homeserver must perform checks to ensure the message is valid</td><td>Only possible to a certain extent</td></tr>
<tr><td>Non-repudiation</td><td>Group members must be able to identify the sender of a message</td><td></td></tr>
<tr><td>Confidentiality</td><td>The homeserver must not learn the identity of the sender</td><td>Authentication can be done pseudonymously</td></tr>
<tr><td>Availability</td><td>Users should always be able to send messages to groups that they are members of</td><td></td></tr>
<tr><td>Authorization</td><td>Not a risk. All group members should be able to send messages</td><td></td></tr>
<tr><td>Spam prevention</td><td>The homeserver must limit the number of message deliveries, as they are message sending</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="federated-homeservers-1"><a class="header" href="#federated-homeservers-1">Federated Homeservers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="federated-users-1"><a class="header" href="#federated-users-1">Federated Users</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="federated-clients-1"><a class="header" href="#federated-clients-1">Federated Clients</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptographic-primitives-and-schemes"><a class="header" href="#cryptographic-primitives-and-schemes">Cryptographic primitives and schemes</a></h1>
<p>To fulfill the functional and performance requirements, as well as those for security and privacy, the homeserver will need to employ a number of cryptographic primitives, e.g. signature, authenticated encryption, etc. This chapter discusses the primitives required, as well as the choice of schemes that are used for the initial specification. As customary in other protocol specifications the set of schemes used by a homeserver is called the homeserver's ciphersuite.</p>
<h2 id="federation-and-cryptographic-agility"><a class="header" href="#federation-and-cryptographic-agility">Federation and cryptographic agility</a></h2>
<p>Each homeserver operator will have its own requirements with regard to the ciphersuite that they want to use. This could be, for example, due to the requirement for the primitives to be certified in some way, or to meet a specific level of security for organizational policy reasons.</p>
<p>The underlying Messaging Layer Security (MLS) supports agility for a number of reasons and homeservers should, too.</p>
<p>For the initial homeserver specification, however, only one ciphersuite will be supported, even though the design will accommodate the requirement for homeservers to advertise their ciphersuite support.</p>
<h2 id="list-of-cryptographic-primitives-and-schemes"><a class="header" href="#list-of-cryptographic-primitives-and-schemes">List of cryptographic primitives and schemes</a></h2>
<p>For now, the homeserver is anticipated to require mostly basic symmetric and asymmetric primitives to fulfill its functional requirements. This is with the exception of an unlinkable token scheme to enable rate-limiting while allowing clients to access the homeservers services anonymously.</p>
<p>Along with the list of primitives, the list also includes a concrete scheme for each primitive that will be used in the initial specification.</p>
<p>In addition to the scheme's fitness to facilitate the listed requirements of the homeserver (functional, security, privacy, performance), an implementation of each scheme has to be available and fulfill the following criteria:</p>
<ul>
<li>Open source with an OSI-recognized license</li>
<li>ideally implemented in Rust</li>
<li>actively and well maintained</li>
</ul>
<p>The RustCrypto suite of cryptographic implementations provides well-maintained Rust implementations of a large variety of cryptographic primitives and schemes. While they are generally not as highly optimized for performance as other available implementations, they provide a good baseline that is sufficient for a PoC homeserver implementation. In the future, we hope to upgrade any implementations we decide on for the PoC with similarly well performing ones that have formally verified properties such as functional correctness and secret-independent execution,</p>
<p>When it comes to the concrete choice of primitives and schemes, an easy choice for the initial specification is the suite of schemes in the “mandatory-to-implement” (MTI) ciphersuite of MLS, as it represents a compromise between security and good performance on a variety of devices. In particular, the primitives and schemes are</p>
<ul>
<li>Signatures: Ed25519</li>
<li>Hash function: SHA256</li>
<li>AEAD scheme: AES128-GCM</li>
<li>KEM: DHKEMX25519</li>
</ul>
<p>Additional recommendations for primitives that might be used in the homeserver specification are</p>
<ul>
<li>MAC: HMAC-SHA256</li>
<li>KDF: HKDF-SHA256</li>
</ul>
<p>While these are the schemes that should make up the first ciphersuite of the homeserver, the specification should remain modular, such that multiple schemes can be supported and different versions of the homeserver protocols can introduce or deprecate individual ciphersuites.</p>
<p>All schemes above have been well-tested in a variety of modern, cryptographic protocols (e.g. Signal, TLS). The only choice that might not be immediately obvious is AES128-GCM as AEAD scheme, since in many cases, Chacha20-Poly1905 is frequently used as a more efficient scheme on devices that don’t have hardware support for AES, most of those with ARM processors. However, with the most recent generations of ARM processors supporting AES instructions, AES128-GCM is a good choice for a first ciphersuite, given that support for multiple ciphersuites is planned for the future.</p>
<h2 id="unlinkable-tokens"><a class="header" href="#unlinkable-tokens">Unlinkable tokens</a></h2>
<p>Should unlinkable tokens be used to facilitate a metadata friendly rate-limiting mechanism, their performance is essentially to not ultimately represent a denial of service vulnerability themselves.</p>
<p>Since the Privacy Pass protocol is the only well-known unlinkable token scheme that has seen extensive real-world use and analysis, it is recommended as the protocol of choice for metadata-friendly rate-limiting. Besides its use in practice, it is also on the finishing stretch of the IETF standardization process. Privacy Pass defines a number of token types, each backed by another cryptographic scheme. Performance tests have revealed, however, that all schemes suggested in the draft specification are prohibitively expensive in terms of computational overhead in the various protocol operations. To mitigate this shortcoming, the authors of this document have proposed a new batched token type based on the <a href="https://datatracker.ietf.org/doc/draft-irtf-cfrg-ristretto255-decaf448/">Ristretto255</a> group (also in the process of IETF standardization), which has significantly improved performance over the schemes used by existing token types. These improved results come at a slight security cost, which can be mitigated by a conservative key rotation policy.</p>
<p>The authors have already performed initial performance tests justifying the effort and published <a href="https://raphaelrobert.github.io/privacypass-batched-tokens/draft-robert-privacypass-batched-tokens.html">a document</a> defining the new token type, as well detailing the security recommendations for consideration by the Privacy Pass working group at the IETF.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="specification-draft"><a class="header" href="#specification-draft">Specification (Draft)</a></h1>
<p>This section contains a draft of the MLS homeserver specification. It is currently in an early draft status, but the goal is for it to fulfill the <a href="./functional_requirements.html">functional requirements</a> and be the target for analysis via the <a href="./threat_model.html">threat model</a>.</p>
<p>Note that federation features are still work in progress.</p>
<p>The specification is split into subsections according to the modular structure of the homeserver. In particular, the specification covers the following modules.</p>
<h2 id="work-in-progress-authentication-service-as"><a class="header" href="#work-in-progress-authentication-service-as">Work in progress: Authentication Service (AS)</a></h2>
<p>This section of the specification is still work in progress. As such it is currently incomplete and subject to significant changes.</p>
<p>The <a href="spec/authentication_service.html">authentication service</a> deals with user and client management, as well as user and client identity. For each user, it keeps an AS user record that contains the user name, as well as identifiers and cryptographic key material of the user's devices. The AS also provides the necessary funtionality for <a href="spec/authentication_service/connection_establishment.html">discovery and connection establishment</a>.</p>
<p>When communicating with the AS, users and their clients authenticate themselves using their real identity. This is as opposed to the rest of the homeserver, where each user has a pseudonym that they use for authentication.</p>
<h2 id="work-in-progress-anonymous-authentication-service-aas"><a class="header" href="#work-in-progress-anonymous-authentication-service-aas">Work in progress: Anonymous Authentication Service (AAS)</a></h2>
<p>This section of the specification is still work in progress. As such it is currently incomplete and subject to significant changes.</p>
<p>The anonymous authentication module allows the operator of the homeserver to rate-limit homeserver access to users and federated homeservers. The AAS acts as a middleware gating access to the endpoints of all other modules with the exception of the user registration endpoint of the AS. Registered clients can obtain anonymous (Privacy Pass) tokens from the AAS, the quantity of which can be configured by the homeserver operator. These tokens can then presented to the AAS when accessing other homeserver endpoints.</p>
<h2 id="queuing-service-qs"><a class="header" href="#queuing-service-qs">Queuing Service (QS)</a></h2>
<p>The queuing service stores queued messages for each client and forwards messages to remote queuing services. It also stores MLS KeyPackages uploaded by clients that allow users to add connected users to groups. After registration with the AS, clients can create a pseudonymous group message queue and upload KeyPackages. The homeserver's DS can deliver messages to individual queues and ask the QS to store-and-forward messages to remote QS'.</p>
<p>The queues and KeyPackages of a user's clients are organized on the QS in a QS user record. This record is not linked directly to the user's AS user record and prevents the homeserver from gathering metadata of individual users. For more information see the homeserver's <a href="threat_model.html">threat model</a>.</p>
<h2 id="delivery-service-ds"><a class="header" href="#delivery-service-ds">Delivery Service (DS)</a></h2>
<p>The delivery service is fulfills the role of the service of the same name described in the <a href="https://www.ietf.org/id/draft-ietf-mls-architecture-08.html#section-4.3">MLS architecture document</a>. Clients can use it to create new groups and deliver MLS messages to these groups. Group member management is transparent via the MLS-native member management.</p>
<p>Communication between clients and the DS is authenticated based on per-group pseudonyms. Each distinct pseudonym used by a given user on the DS is linked to the user's pseudonymous record on the QS via the <a href="spec/glossary.html#sealed-queue-config">ClientQueueConfig</a> of each of the user's clients. In particular, this means that a DS alone cannot correlate group memberships of a given user. While not very meaningful in the context of an individual homeserver, this separation of pseudonyms is more relevant in the federated setting.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="work-in-progress-authentication-service-as-1"><a class="header" href="#work-in-progress-authentication-service-as-1">Work in progress: Authentication Service (AS)</a></h1>
<p>In this chapter, we detail the different functionalitites of the authentication service. See the subchapter on <a href="spec/authentication_service/credentials.html">credentials</a> for more details on the credential types referenced in this chapter.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The AS is configurable by use of the following configuration variables:</p>
<ul>
<li><strong>Anonymous token timeframe:</strong> The amount of time which each client has to wait until it can obtain new anonymous authentication tokens.</li>
<li><strong>Default token allowance:</strong> The default amount of anonymous authentication tokens issued to each user in the anonymous token timeframe.</li>
<li><strong>Identity provider:</strong> Network address of the OpenID connect identity provider the authentication service delegates authentication to for account registration.</li>
<li><strong>Maximal QS client record age:</strong> Maximal age of an inactive client entry.
<ul>
<li>Default: 90d</li>
</ul>
</li>
<li><strong>Maximal number of requested messages:</strong> Maximal number of messages that will be returned to a client requesting messages from a direct queue.</li>
<li><strong>Identity provider (IdP):</strong> Provider used for user authentication
<ul>
<li><strong>Provider URL:</strong> URL under which the provider (issuer) can be reached</li>
<li><strong>Client ID:</strong> ID of the AS as the IdP's client</li>
<li><strong>Client secret:</strong> Secret which the AS can use to authenticate itself towards the IdP</li>
</ul>
</li>
</ul>
<h2 id="as-state"><a class="header" href="#as-state">AS state</a></h2>
<p>The AS generally keeps the following state</p>
<ul>
<li><strong>User entries:</strong> A database with one entry for each user account. Each entry is indexed by the user's <a href="spec/glossary.html#user-name-un">user name</a> and contains a number of sub-entries.
<ul>
<li><strong>User IdP identity:</strong> The user's identity at the user's IdP. Required for authentication with the IdP.</li>
<li><strong>Client entries:</strong> Sub entries for each of the user's clients. Indexed by the clients' <a href="spec/glossary.html#client-id-cid">client id</a>.
<ul>
<li><strong>Client credential:</strong> The <a href="spec/authentication_service/credentials.html#client-credentials">credential</a> of the client.</li>
<li><strong>Token issuance records:</strong> A record of how many tokens were issued to the client.</li>
<li><strong>Activity time:</strong> Timestamp indicating the last time a client has fetched messages from the queue.</li>
<li><strong>Connection establishment KeyPackage:</strong> A key package used to encrypt information in the <a href="spec/authentication_service/connection_establishment.html">connection establishment process</a>.</li>
<li><strong>Direct queue:</strong> A queue similar to the fan-out queues on the QS.
<ul>
<li><strong>Queue encryption key material:</strong> Key material to perform <a href="spec/./queuing_service/queue_encryption.html">queue encryption</a>.
<ul>
<li><strong>Queue encryption key:</strong> HPKE public key of the queue owner</li>
<li><strong>Encryption ratchet key:</strong> Symmetric key used to derive queue encryption keys.</li>
</ul>
</li>
<li><strong>Current sequence number:</strong> The current message sequence number.</li>
<li><strong>Queued messages:</strong> A sequence of ciphertexts containing the messages in the queue. Each incoming message is <a href="spec/./queuing_service/queue_encryption.html">encrypted</a> and is assigned the current sequence number, after which the current sequence number is incremented.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h2>
<p>The AS uses the user's IdP to authenticate the user. Some endpoints require simple authentication, while for others, the AS requires MFA authentication via the IdP.</p>
<h2 id="user-account-registration"><a class="header" href="#user-account-registration">User account registration</a></h2>
<p>The user registration functionality delegates authentication to an OpenID connect-capable identity provider. Note, that the user's chosen user name is part of the <code>client_csr</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateUserParams {
  idp_identity: Vec&lt;u8&gt;,
  client_csr: ClientCsr,
  queue_encryption_key: HpkePublicKey,
}
<span class="boring">}
</span></code></pre></pre>
<p>The AS uses the given <code>idp_identity</code> to authenticate the user with the IdP and then creates the user entry and initial client entry. The AS then signs the CSR and returns it to the client.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateUserResponse {
  client_credential: ClientCredential,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="future-work-sybil-attack-protection"><a class="header" href="#future-work-sybil-attack-protection">Future work: Sybil attack protection</a></h3>
<p>Being able to create arbitrarily many users can enable a number of DDoS attacks and effectively renders the anonymous token DDoS prevention strategy useless. Thus we need some form of restriction here, such as a CAPTCHA or other proof of personhood.</p>
<h2 id="get-user-clients"><a class="header" href="#get-user-clients">Get user clients</a></h2>
<p>Given a user name, get the <a href="spec/authentication_service/credentials.html#client-credentials">client credentials</a> of all of the user's clients.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GetClientCredentialsParams {
  user_name: UserName,
}
<span class="boring">}
</span></code></pre></pre>
<p>The AS returns the following information.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GetClientCredentialsResponse {
  client_credentials: Vec&lt;ClientCredential&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="user-account-deletion"><a class="header" href="#user-account-deletion">User account deletion</a></h2>
<p>Delete the user account with the given user name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DeleteUserParams {
  user_name: UserName,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="authentication-2"><a class="header" href="#authentication-2">Authentication</a></h3>
<p>Requires MFA authentication as the user's <code>idp_identity</code> with the IdP.</p>
<h2 id="add-new-client"><a class="header" href="#add-new-client">Add new client</a></h2>
<p>Add a new client entry to the user's user entry.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateClientParams {
  idp_identity: Vec&lt;u8&gt;,
  client_csr: ClientCsr,
  queue_encryption_key: HpkePublicKey,
}
<span class="boring">}
</span></code></pre></pre>
<p>The AS validates the CSR, creates the client entry, signs the CSR and returns it to the client.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateClientResponse {
  client_credential: ClientCredential,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="authentication-3"><a class="header" href="#authentication-3">Authentication</a></h3>
<p>Requires MFA authentication as the user's <code>idp_identity</code> with the IdP.</p>
<h2 id="delete-client"><a class="header" href="#delete-client">Delete client</a></h2>
<p>Delete the client with the given client id. This endpoint can't be used to delete the last client entry in a given user entry.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DeleteClientParams {
  client_id: ClientId,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="authentication-4"><a class="header" href="#authentication-4">Authentication</a></h3>
<p>Requires MFA authentication as the user's <code>idp_identity</code> with the IdP.</p>
<h2 id="get-client-entry"><a class="header" href="#get-client-entry">Get client entry</a></h2>
<p>Get the information contained in a client entry.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GetClientEntryParams {
  client_id: ClientId,
}
<span class="boring">}
</span></code></pre></pre>
<p>The AS responds with the following struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GetClientEntryResponse {
  client_credential: ClientCredential,
  queue_encryption_key: HpkePublicKey,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="authentication-5"><a class="header" href="#authentication-5">Authentication</a></h3>
<p>Requires authentication as the user's <code>ipd_identity</code> with the IdP.</p>
<h2 id="dequeue-messages"><a class="header" href="#dequeue-messages">Dequeue messages</a></h2>
<p>Dequeue messages from a client's direct queue, starting with the message with the given sequence number.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DequeueMessagesParams {
  client_id,
  sequence_number_start: u64,
  max_message_number: u64,
}
<span class="boring">}
</span></code></pre></pre>
<p>The AS deletes messages older than the given sequence number and returns messages starting with the given sequence number. The maximum number of messages returned this way is the smallest of the following values.</p>
<ul>
<li>The number of messages remaining in the queue</li>
<li>The value of the <code>max_message_number</code> field in the request</li>
<li>The AS configured maximum number of returned messages</li>
</ul>
<h2 id="enqueue-message"><a class="header" href="#enqueue-message">Enqueue message</a></h2>
<p>Enqueue a message into a clien'ts direct queue.</p>
<h2 id="get-as-credentials"><a class="header" href="#get-as-credentials">Get AS credentials</a></h2>
<p>Get the currently valid <a href="spec/authentication_service/credentials.html#as-credentials">AS credentials</a> and <a href="spec/authentication_service/credentials.html#as-intermediate-credentials">AS intermediate credentials</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GetCredentialsResponse {
  as_credentials: Vec&lt;AsCredentials&gt;,
  as_intermediate_credentials: Vec&lt;AsIntermediateCredential&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="future-work-revocation"><a class="header" href="#future-work-revocation">Future work: Revocation</a></h3>
<p>For now, revocation happens by the AS stopping to publish a given cert. In the future, we might want a more sophisticated revocation story closer to what's happening in the WebPKI.</p>
<h2 id="future-work-evolving-identity"><a class="header" href="#future-work-evolving-identity">Future work: Evolving Identity</a></h2>
<p>For now, the AS relies on <a href="spec/glossary.html#client-credential-chain">client credential chains</a>, but in the future, client authentication should be achieved using <a href="spec/authentication_service/evolving_identities.html">evolving identity</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="work-in-progress-credentials"><a class="header" href="#work-in-progress-credentials">Work in progress: Credentials</a></h1>
<h2 id="as-credentials"><a class="header" href="#as-credentials">AS credentials</a></h2>
<h2 id="as-intermediate-credentials"><a class="header" href="#as-intermediate-credentials">AS intermediate credentials</a></h2>
<h2 id="client-credentials"><a class="header" href="#client-credentials">Client credentials</a></h2>
<h3 id="client-credential-signing-requests"><a class="header" href="#client-credential-signing-requests">Client credential signing requests</a></h3>
<h2 id="intermediate-client-credentials"><a class="header" href="#intermediate-client-credentials">Intermediate client credentials</a></h2>
<h2 id="leaf-credentials"><a class="header" href="#leaf-credentials">Leaf credentials</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-work-evolving-identity-eid"><a class="header" href="#future-work-evolving-identity-eid">Future work: Evolving Identity (EID)</a></h1>
<p>On a high level, the evolving identity represents a user's identity, which in turn is composed of the cryptographic identities of all of the user's devices.</p>
<p>More concretely, this is implemented using an MLS group that includes all of a user's clients, with the group's <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-ratchet-tree-concepts">ratcheting tree</a> representing the user's EID state.</p>
<p>Users update their EID by performing commits in the group using <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-message-framing">MLS plaintexts</a> as their framing.</p>
<h2 id="the-eid-state"><a class="header" href="#the-eid-state">The EID state</a></h2>
<p>The EID state is the ratcheting tree of an MLS group that contains all of a user's devices. It defines the user's cryptographic identity, but it's also the place of publication for the <a href="spec/authentication_service/credentials.html#client-credentials">client credentials</a> of all of the user's clients.</p>
<p>The leaves in the EID state thus don't contain Leaf Credentials like the leaves in other groups, but instead contain the client credential of the client represented by the leaf.</p>
<p>The EID state is managed by the client, but published by the AS and held by all clients that communicate with the user.</p>
<h2 id="client-management-1"><a class="header" href="#client-management-1">Client management</a></h2>
<p>The EID is the authoritative list of the user's clients. Any change to the user's line-up of clients thus needs to be first made in the EID.</p>
<p>Since the EID is at its core an MLS group, changes to a user's device can be made using MLS membership management operations such as commits to update, add and remove proposals.</p>
<p>Any commit to such a change needs to be sent to the AS for publication, but also to all of the user's groups. In order for all these parties to be able to track changes to the user's identity, the commit needs to be in an MLS plaintext message. Any recipient of such a commit can validate the visible information in the commit, and in particular verify the signature against the current state of the EID.</p>
<h3 id="cross-signing"><a class="header" href="#cross-signing">Cross-signing</a></h3>
<p>One goal of the EID is to implement two-directional client cross signing, i.e. have both the adding client and the added client confirm the addition with their signatures. To achieve this, recipients of a commit to the EID that contains a client addition MUST wait for a second commit sent by the new client that only contains an update by that client.</p>
<h2 id="future-work-user-id-changes"><a class="header" href="#future-work-user-id-changes">Future work: User ID changes</a></h2>
<p>In a future iteration, users will be able to change their user name by terminating their existing EID and starting a new one. The old and the new EID group will be cross-linked to one-another cryptographically to ensure that the user name change is fully authenticated.</p>
<h2 id="future-work-as-tickets"><a class="header" href="#future-work-as-tickets">Future work: AS tickets</a></h2>
<p>There is currently no way for other clients to judge how recent a given EID state is. Having a strict bound on how recent an EID is required to be is important to ensure prompt propagation of client removal. Adding a &quot;ticket&quot;, i.e. a signed message from the AS containing a time stamp and the hash of the EID state could help with this.</p>
<p>The protocol would then be extended by requiring clients to regularly upload a ticket attesting the validity and recency of the EID state currently uploaded to the group. Clients receving a message from another client could then always require that the client's AS ticket be recent (for a configurable definition of &quot;recent&quot;).</p>
<p>It's not clear yet, though, what exactly the AS should sign, since it doesn't know the ciphertext used in each group, so it can only sign the plaintext, which the DS can't check.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-workwork-in-progress-registering-a-new-device-when-using-evolving-identity"><a class="header" href="#future-workwork-in-progress-registering-a-new-device-when-using-evolving-identity">Future work/Work in progress: Registering a new device when using Evolving Identity</a></h1>
<p>To register a new client, the user needs to be in possession of one of his existing clients. To properly perform the <a href="spec/authentication_service/evolving_identities.html">evolving identity</a> (EID) operation and securely transfer data from the existing client to the new client, this chapter defines a protocol between new client, the owning user's homeserver and an existing client. The protocol proceeds roughly in the following steps:</p>
<ul>
<li>Establish a channel between new client and old client via the homeserver's rendez-vous service (defined below)</li>
<li>Secure the channel with mutual authentication with the help of the user and a Password-authenticated Key Exchange (PAKE)</li>
<li>Use the secure channel to exchange the information required to add the new client to the user's EID</li>
<li>Add the new client to the user's EID</li>
<li>Transfer user-specific secrets from existing client to new client via the secure channel</li>
<li>Perform the remaining set-up of the new client using the user-specific secrets (QS client record creation at QS, KeyPackage publiction, etc)</li>
</ul>
<h2 id="rendez-vous-service"><a class="header" href="#rendez-vous-service">Rendez-vous service</a></h2>
<p>The existing client and the new client need to communicate in multiple round trips to complete the registration of the new client. The user's homeserver facilitates this by providing a rendez-vous service (RS), which acts as a network proxy between existing and new client.</p>
<p>The RS allows a new client to request a rendez-vous code (RC), which consists of a 16bit randomly generated byte-string.</p>
<p>The new client then establishes a connection to the RS and waits for the new client to also establish a connection using the same RC.</p>
<p>For the new client to establish a connection, the new client displays the RC for the user to manually enter on the new existing (along with the password for the subsequent PAKE, see below).</p>
<p>Once both clients have established a connection, the RS acts as a proxy, forwarding incoming messages from one client to the other.</p>
<p>Due to UX constraints, the new client is expected to initiate the process, which means that the RS has to provide a public (unauthenticated) interface to facilitate the first step. As a result, this interface should be subject to strict (traditional) rate-limiting measures.</p>
<p>The existing client is already registered with the homeserver can be expected to present an <a href="spec/authentication_service/../general_concepts/anonymous_tokens.html">anonymous token</a> when it's connecting to the RS, thus enabling at least partial rate-limiting.</p>
<h2 id="mutual-authentication-between-new-and-existing-client"><a class="header" href="#mutual-authentication-between-new-and-existing-client">Mutual authentication between new and existing client</a></h2>
<p>Once the network channel is established via the RS, the two clients perform an <a href="https://www.ietf.org/id/draft-irtf-cfrg-spake2-26.html">SPAKE2</a> handshake to agree on a key, which they subsequently use to encrypt all messages sent over the RS channel.</p>
<p>SPAKE2 requires that the two clients share a password. The password is randomly generated by the new client and displayed to the user such that it can enter it (along with the similarly displayed RC) into the existing client.</p>
<p>The SPAKE2 PAKE consists of two phases. In each phase, both clients send one message to the other client. After generating the password, the new client can complete phase 1 and send its message to the existing client. Once the password (and RC) was entered into the existing client, it can also send its message for phase 1 and retrieve the message from the new client.</p>
<p>Both clients use the other client's message to complete phase 1 and exchange the messages of phase 2 via the RS.</p>
<p>After completing both phases, the clients have agreed on a symmetric key, which they can use to encrypt further messages using an AEAD algorithm.</p>
<h2 id="adding-the-new-client-to-the-users-eid"><a class="header" href="#adding-the-new-client-to-the-users-eid">Adding the new client to the user's EID</a></h2>
<p>The new client now creates a <a href="spec/authentication_service/../authentication_service/credentials.html#client-credential-signing-requests">Client Credential Signing Request</a> and sends it to the existing client. The existing client in turn signs it with its own client credential private key and submits it to the AS for signing. The existing client then forwards the AS' response to the new client.</p>
<p>With its signed Client Credential, the new client can now create a KeyPackage (which includes the Client Credential) for the EID and send it to the existing client. The existing client subsequently uses the KeyPackage to create the commit adding the new client to the EID and submits it to the AS. The existing client then sends the resulting Welcome, as well as the following user-specific secrets to the new client.</p>
<ul>
<li>user base secret</li>
<li>QS user auth key</li>
<li>friendship secret</li>
</ul>
<p>The existing client also sends group joining bundles for all of the user's groups. The group joining bundle allows the new client to perform an external commit in all groups that the user is a part of. It contains the following group-specific data:</p>
<ul>
<li>
<p>Group ID</p>
</li>
<li>
<p>Group state EAR base secret</p>
</li>
<li>
<p>Credential encryption base secret</p>
</li>
<li>
<p>The new client contacts the AS and asks for a rendez-vous code.</p>
</li>
<li>
<p>The AS responds with a 16bit rendez-vous code.</p>
<ul>
<li>It might be more than 16bit if the 16bit space was exhausted by an adversary.</li>
</ul>
</li>
<li>
<p>The new client samples a 16bit random string and prompts the user to enter both the rendez-vous code and the random string into the existing client.</p>
</li>
<li>
<p>The new client uses the random string and the rendez-vous code to perform the first part of an SPAKE2 handshake, where the random string is used as the password and the rendez-vous code is used as the identity. It then establishes a websocket connection with the AS using the rendez-vous code and uploads the SPAKE2 outgoing message.</p>
</li>
<li>
<p>The existing client performs the responder's part of the SPAKE2 handshake and also establishes a websocket connection to the AS using the rendez-cous code. It then uploads the resulting outgoing message to the AS, picking up the new client's outgoing message in the process and completes the first phase of the SPAKE2 handshake.</p>
</li>
<li>
<p>The AS alerts the new client of the new upload.</p>
</li>
<li>
<p>The new client downloads the outgoing message, completes phase 2 of the SPAKE2 and uploads the key confirmation message.</p>
</li>
<li>
<p>The existing client downloads the confirmation message and posts its own confirmation message.</p>
</li>
<li>
<p>The new client downloads the existing client's confirmation message and uploads a CSR, which it AEAD-encrypts using the agreed-upon key.</p>
</li>
<li>
<p>The existing client downloads the CSR and submits it to the AS for signature, signing the request with its client credential.</p>
<ul>
<li>TODO: CSR submission has to happen via another endpoint.</li>
</ul>
</li>
<li>
<p>The AS validates the signature and the CSR and sends the signed credential to the new client via the websocket connection.</p>
<ul>
<li>TODO: The AS shouldn't send the signed CSR to the new client, but to the existing client, which then forwards it.</li>
</ul>
</li>
<li>
<p>The new client creates a KeyPackage for the EID, as well as for the user's all-clients group and uploads it, along with the corresponding intermediate certificate. All uploads are encrypted using the AEAD key.</p>
</li>
<li>
<p>The AS notifies the existing client of the upload.</p>
</li>
<li>
<p>The existing client downloads and validates it and uses the KeyPackage to add the new client to the EID. It sends the resulting commit to all other existing clients and the AS. The existing client also adds the new client to the user's all-clients group. It then uploads the Welcome for the EID and the all-clients group to the AS. Note that the Welcome for the all-clients group contains the EAR secrets for the group.</p>
</li>
<li>
<p>The new client downloads the Welcome and joins the group. It then requests anonymous tokens from the AS, authenticating the request with its client credential.</p>
</li>
<li>
<p>The AS repsonds with the tokens.</p>
</li>
<li>
<p>The new client contacts the QS to create its queues.</p>
</li>
<li>
<p>The existing client sends the client state to the new client via the all-client group. The new client state includes state-bundles for all groups that the user is in. These bundles include the group ID, member EAR secrets and PublicGroupStates of each group.</p>
</li>
<li>
<p>The new client injects itself into all of the user's group using the state-bundles. It sends attached the two commits for the EID state.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="discovery-and-connection-establishment"><a class="header" href="#discovery-and-connection-establishment">Discovery and connection establishment</a></h1>
<p>Discovery allows users to find other users based on their user name and establish a connection with them. The connection establishment process establishes a <em>connection group</em> that consists of the devices of both connected users, but otherwise functions like a regular group with the exception of the group creation process.</p>
<p>Once two users have a <em>connection</em>, they can add one-another to groups.</p>
<p>The creation process of a connection group is restricted by two considerations: Until the responding user makes its decision to accept the connection, the initiator is considered untrusted and should not be able to push arbitrary content to the responder. That is with the exception of the initiator's user name which the responder can use to identify the initiator.</p>
<p>The second consideration is that neither of the homeservers involved (with the initiator and reponder potentially belonging to two federated homeservers) should know who is connected to whom. This is not straight-forward, as the initiator has to be able to discover the responder by its real user name and use the discovered information to initiate the process.</p>
<h2 id="connection-group-creation"><a class="header" href="#connection-group-creation">Connection group creation</a></h2>
<p>To allow connection establishment in the first place, every client of a user publishes a special <em>connection establishment KeyPackage</em> with the AS which contains the client's <a href="spec/authentication_service/credentials.html#client-credentials">client credential</a> instead of the Leaf Credential that is used in other KeyPackages.</p>
<p>When discovering a user, the initiator fetches the connection establishment KeyPackages of all of the user's clients. The next step if for the initiator to create a group that contains all of the initiator's clients. The initiator then sends a <code>ConnectionEstablishmentPackage</code> to the responder's clients.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ConnectionEstablishmentPackage {
    sender_client_credential: ClientCredential,
    connection_group_id: GroupId,
    connection_group_ear_key: GroupStateEarKey,
    connection_group_credential_key: CredentialEarKey,
    // TBS: All information above signed by the ClientCredential.
    signature: Signature,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>ConnectionEstablishmentPackage</code>s are then signed using the initiator's client credential and each encrypted under the init key of the connection establishment KeyPackage of the responder's individual clients.</p>
<p>Receiving the <code>ConnectionEstablishmentPackage</code>, a responder's client must verify the signature on the package. It must also fetch the AS credential and AS intermediate credential and verify the signature chain from the initiator's client credential to the AS credential. The responder can then decide based on the sender's user name (contained in the client credential) if it wants to accept the connection.</p>
<p>The responder accepts the connection by fetching the external commit information required to join the group from the initiator's DS and joins the group via the <em>join connection group</em> endpoint of said DS.</p>
<h3 id="future-work-additional-initiator-information"><a class="header" href="#future-work-additional-initiator-information">Future work: Additional initiator information</a></h3>
<p>In some cases, the responder might want to get additional information to validate the responder, such as a display name or a profile picture. The responder should not get this information delivered immediately, but instead it should be downloaded upon active request by the responder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delivery-service-ds-1"><a class="header" href="#delivery-service-ds-1">Delivery Service (DS)</a></h1>
<p>The delivery service keeps track of groups and (pseudonymous) group membership and delivers messages to group members.</p>
<h2 id="ds-configuration-options"><a class="header" href="#ds-configuration-options">DS configuration options</a></h2>
<ul>
<li>Maximal KeyPackageBatch age: Maximal difference between a KeyPackageBatch timestamp and the current time when a new user is added to a group.
<ul>
<li>Default: 1h</li>
</ul>
</li>
<li>Maximal DSAuthToken age: Maximal age of an <a href="spec/delivery_service.html#authentication">DSAuthToken</a> presented to the DS for client authentication.
<ul>
<li>Default: 1h</li>
</ul>
</li>
<li>Maximal duration of client commit inactivity: Maximal duration between two commits of an individual client before the removal of the client is proposed by the DS.
<ul>
<li>Default: 90d</li>
</ul>
</li>
</ul>
<h2 id="ds-state"><a class="header" href="#ds-state">DS state</a></h2>
<p>The DS has a database of EAR encrypted group states indexed by their group ID.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GroupStateDbEntry {
  encrypted_group_state: Vec&lt;u8&gt;,
  timestamp: Timestamp,
  deleted_queues: Vec&lt;SealedQueueConfig&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The plaintext group state contains the following data:</p>
<ul>
<li><strong>Public ratchet tree:</strong> The public MLS ratchet trees of the group.</li>
<li><strong>MLS GroupInfo:</strong> The <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-adding-members-to-the-group">GroupInfo</a> of this group.</li>
<li><strong>User profile:</strong> For each user that has at least one client in the group, the DS keeps the following records.
<ul>
<li><strong>Clients:</strong> The leaf indices of each client belonging to the user.</li>
<li><strong>User auth key:</strong> Public signature key known to all clients of a given user.</li>
</ul>
</li>
<li><strong>Client profile:</strong> For each client in the group, the DS keeps the following records.
<ul>
<li><strong>Client index:</strong> The client's leaf index in the public group tree.</li>
<li><strong>Client credential chain (encrypted):</strong> The intermediate client credentials for each of the user's clients, as well as the client's client credential, encrypted using the group state encryption key.</li>
<li><strong>Client queue config:</strong> The <a href="spec/glossary.html#sealed-queue-config">client queue config</a> of the client.</li>
<li><strong>Activity time:</strong> A timestamp indicating either the time the client was added, or the last time the client has sent a commit (whatever is more recent).</li>
<li><strong>Activity epoch:</strong> Epoch of the last time the client has sent a commit (see activity time).</li>
</ul>
</li>
<li><strong>Past group states:</strong> Whenever a new KeyPackage is added to the group, the DS files a copy of the current epoch's group state and keeps it until all group members added in a given, past epoch have updated, or until all KeyPackages added in the given epoch have expired. The copies include the following data:
<ul>
<li><strong>Public ratchet tree</strong></li>
<li><strong>Client credential chain (encrypted)</strong></li>
<li><strong>Joining clients:</strong> List of the KeyPackagerefs of all clients that are expected to pick up this group state.</li>
</ul>
</li>
<li><strong>Proposal store:</strong> List of proposals sent in this group in this epoch. Gets cleared upon every epoch change.</li>
</ul>
<h2 id="proposal-store"><a class="header" href="#proposal-store">Proposal store</a></h2>
<ul>
<li>Proposal store is emptied after each successful commit</li>
<li>Proposals are added to the store either through user self removals,</li>
<li>If the proposal store is non-empty, the next commit must be a client update that contains all proposals in the proposal store. The DS must reject all other operations containing commits.</li>
<li>For all requests containing non-update commits, or commits that do not contain all proposals in the store, the DS will return an error message indicating the the proposal store is non-empty.</li>
</ul>
<h2 id="authentication-6"><a class="header" href="#authentication-6">Authentication</a></h2>
<p>Messages from the client to the DS are authenticated by the client by providing a <code>DsAuthToken</code>, where the <code>DsSenderId</code> in the token depends on the endpoint the client is querying.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DsSenderId {
  LeafIndex(u32),
  KeyPackageRef(KeyPackageRef),
  UserKeyHash(Vec&lt;u8&gt;),
}

struct DsAuthToken {
  group_id: GroupId,
  timestamp: Timestamp,
  sender_id: DsSenderId,
  // TBS: group_id, timestamp and sender_id
  signature: Signature,
}
<span class="boring">}
</span></code></pre></pre>
<p>The verification key used to create the token depends on the <code>sender_id</code>:</p>
<ul>
<li>LeafIndex: Signature key in the leaf's credential</li>
<li>KeyPackageRef: Signature key of the credential in the KeyPackage with the given KeyPackageRef</li>
<li>UserKeyHash: Signature key in the user profile indicated by the UserProfileHash</li>
</ul>
<h2 id="groupinfo-updates"><a class="header" href="#groupinfo-updates">GroupInfo updates</a></h2>
<p>When sending a commit to change the group state, the sender has to enable the DS to update the MLSGroupInfo of the group. Since the DS either already has most of the required data and can extract the rest from the message, the sender only has to include its signature over the new GroupInfo.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GroupInfoUpdate {
  signature: Signature,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-delivery-1"><a class="header" href="#message-delivery-1">Message delivery</a></h2>
<p>The majority of endpoints of the DS allow clients to send MLS messages to groups.</p>
<h3 id="validation"><a class="header" href="#validation">Validation</a></h3>
<p>Whenever receiving an MLS message at any endpoint, the DS checks if a local group state with the message's GroupId exists. If it does, the DS locks the corresponding database entry to prevent concurrent access. The DS then takes the GroupStateEarKey that is part of every message delivery request and decrypts the group state. Finally, the DS performs the same validation steps a receiving MLS client would perform, as well as the endpoint-specific validation steps.</p>
<p>The MLS client checks also includes checking that the epoch numbers match. In the case of commits, this comparison along with the lock on the database entry ensure that any conflicts between commits for the same epoch are resolved.</p>
<p>If all validation steps pass, the DS performs the endpoint and message-specific changes to its local group state.</p>
<h3 id="message-distribution"><a class="header" href="#message-distribution">Message distribution</a></h3>
<p>To distribute MLS messages the DS sends messages on to the local QS to enqueue in a local client's queue or to forward to a federated QS. For the message format see <a href="spec/glossary.html#fan-out-message">here</a>.</p>
<p>In cases where the QS responds with a message indicating that a target queue doesn't exist, the DS assumes that the queue was deleted and proposes the removal of the corresponding group member as specified <a href="spec/delivery_service.html#ds-induced-removals">here</a>.</p>
<h2 id="activity-time"><a class="header" href="#activity-time">Activity time</a></h2>
<p>Whenever a client sends a commit as part of a query to an endpoint, the DS updates the <em>activity time</em> and <em>activity epoch</em> of the sender.</p>
<h2 id="client-endpoints"><a class="header" href="#client-endpoints">Client endpoints</a></h2>
<p>Endpoints meant to be accessed by clients registered with the homeserver via HTTP requests.</p>
<h3 id="request-group-id"><a class="header" href="#request-group-id">Request group id</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_GROUP_ID</code></li>
</ul>
<p>Request a fresh group id for use with the <a href="spec/delivery_service.html#create-group">create group</a> endpoint. The DS samples a fresh group id, checks for collisions and, if none are found, enters the group id as a placeholder into the database. If a collision is found, the DS re-samples until there are no collisions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RequestGroupIdResponse {
  group_id: GroupId,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="authentication-7"><a class="header" href="#authentication-7">Authentication</a></h4>
<ul>
<li>None</li>
</ul>
<h3 id="create-group"><a class="header" href="#create-group">Create group</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_CREATE_GROUP</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateGroupParams {
  group_id: GroupId,
  key_package: KeyPackage,
  encrypted_credential_chain: Vec&lt;u8&gt;,
  creator_queue_config: ClientQueueConfig,
  creator_user_auth_key: UserAuthKey,
  group_info: GroupInfo,
  initial_ear_key: GroupStateEarKey,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The DS checks if there is a placeholder in the group database for this group id. If there is, it creates the GroupStateDbEntry.</li>
</ul>
<h4 id="authentication-8"><a class="header" href="#authentication-8">Authentication</a></h4>
<ul>
<li>DsSenderId: UserKeyHash</li>
</ul>
<h4 id="future-work-obfuscate-group-creator"><a class="header" href="#future-work-obfuscate-group-creator">Future work: Obfuscate group creator</a></h4>
<ul>
<li>A leaf index of 0 can be a strong indicator that the client with that index is the original creator of the group.</li>
<li>It would be good to allow clients to start groups with them in another position than 0.</li>
</ul>
<h3 id="update-queue-information"><a class="header" href="#update-queue-information">Update queue information</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_UPDATE_QUEUE_INFO</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UpdateQueueInfoParams {
  group_id: GroupId,
  group_state_ear_key: GroupStateEarKey,
  new_queue_config: ClientQueueConfig,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="authentication-9"><a class="header" href="#authentication-9">Authentication</a></h4>
<ul>
<li>DsSenderId: LeafIndex</li>
</ul>
<h3 id="get-welcome-information"><a class="header" href="#get-welcome-information">Get Welcome information</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_WELCOME_INFO</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WelcomeInfoParams {
  group_id: GroupId,
  group_state_ear_key: GroupStateEarKey,
  epoch: Epoch,
}

struct WelcomeInfoResponse {
  public_tree: MlsRatchetTree,
  credential_chains: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="authentication-10"><a class="header" href="#authentication-10">Authentication</a></h4>
<ul>
<li>DSSenderId: KeyPackageRef</li>
</ul>
<h3 id="get-external-commit-information"><a class="header" href="#get-external-commit-information">Get External Commit information</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_EXTERNAL_COMMIT_INFO</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ExternalCommitInfoParams {
  group_id: GroupId,
  group_state_ear_key: GroupStateEarKey,
}

struct WelcomeInfoResponse {
  group_info: GroupInfo,
  public_tree: MlsRatchetTree,
  credential_chains: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="authentication-11"><a class="header" href="#authentication-11">Authentication</a></h4>
<ul>
<li>DSSenderId: UserKeyHash</li>
</ul>
<h3 id="adding-new-users-to-the-group"><a class="header" href="#adding-new-users-to-the-group">Adding new users to the group</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_ADD_USERS</code></li>
</ul>
<p>Operation, where the commit contains one or more inline Add proposals containing clients of one or more new users. The sender has to additionally provide a signature of the user's QS to help the DS validate that the KeyPackages indeed all belong to one user, as well as a timestamp to prove that the KeyPackages were recently obtained.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AddUsersParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
  welcome: Welcome,
  welcome_attribution_info: Vec&lt;WelcomeAttributionInfo&gt;,
  key_package_batches: Vec&lt;KeyPackageBatch&gt;,
}

struct AddUsersParamsAad {
  encrypted_credential_information: Vec&lt;Vec&lt;u8&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>commit</code> must include the <code>AddUserParamsAad</code> of all added users in the AAD of the MLSContent, where the ciphertexts in the <code>encrypted_credential_information</code> are sorted in the same way as the Add proposals in the <code>commit</code>.</p>
<p>This operation can only be performed by clients of users marked as <em>admin</em> and all KeyPackages have to contain an extension that contains a <a href="spec/./glossary.html#sealed-queue-config">ClientQueueConfig</a>.</p>
<p>Upon reception, the DS hashes the KeyPackages in all Add proposals contained in the commit. The KeyPackageBatches indicate, which KeyPackages belong to which user. If there are KeyPackages for which there is no matching KeyPackageRef in any KeyPackageBatch, or if there is a KeyPackageRef in a batch that has no corresponding Add proposal, the commit is invalid. Otherwise, the DS creates a user proile for each batch with the leaf indices of the KeyPackages referenced within. The user auth key of the new user remains empty until the first update of one of the user's clients.</p>
<p>The DS also has to verify that the timestamp is not older than the DS' configured maximal KeyPackageBatch age.</p>
<p>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue. It also sends <a href="spec/./glossary.html#welcomebundle">WelcomeBundles</a> to the newly added clients.</p>
<h4 id="authentication-12"><a class="header" href="#authentication-12">Authentication</a></h4>
<ul>
<li>DsSenderId: UserKeyHash</li>
</ul>
<h4 id="future-work-tighten-up-ds-validation-using-zero-knowledge-proofs"><a class="header" href="#future-work-tighten-up-ds-validation-using-zero-knowledge-proofs">Future work: Tighten up DS validation using Zero-Knowledge proofs</a></h4>
<ul>
<li>ZKPs could allow the DS to verify that the sender of a Welcome sends the correct encrypted information</li>
<li>Alternatively, the recipient of the Welcome could let the DS know that it received a bogus Welcome. The problem here is how the recipient can prove that the Welcome is indeed bogus.</li>
</ul>
<h3 id="remove-users"><a class="header" href="#remove-users">Remove users</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_REMOVE_USERS</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RemoveUserParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The commit must exclusively contain Remove proposals</li>
<li>The commit must contain Remove proposals for all clients of all evicted users</li>
<li>The sending client must be a client of an admin</li>
<li>The DS validates the commit and updates its public tree</li>
<li>The DS removes the user profiles for the evicted users and the encrypted credential information of all of their clients</li>
<li>Note, that a user can't remove itself due to MLS constraints</li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-13"><a class="header" href="#authentication-13">Authentication</a></h4>
<ul>
<li>DsSenderId: UserKeyHash</li>
</ul>
<h3 id="updating-the-sending-clients-own-key-material"><a class="header" href="#updating-the-sending-clients-own-key-material">Updating the sending client's own key material</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_UPDATE_CLIENT</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UpdateClientParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
}

struct UpdateClientParamsAad {
    option_encrypted_credential_information: Option&lt;Vec&lt;u8&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>DS validates the commit and changes its public tree
<ul>
<li>The commit must contain an update path, as well as all pending proposals</li>
<li>If the credential in the sender's KeyPackage has changed, there must be encrypted credential information in the AAD</li>
</ul>
</li>
<li>If there is encrypted client credential information in the commit's AAD, the DS also updates its corresponding state</li>
<li>If a remove proposal is committed as part of the commit, the DS removes the associated client profile and updates the owning user's user profile. If the remove proposal removes the last client of a user, it also removes the associated user profile.</li>
<li>If the KeyPackageRef of the updating client (prior to applying the update) is in one of the <em>joining clients</em> vectors in the group's storage of old group states, the DS removes that KeyPackageRef from the vector. If this leaves te vector empty, the DS removes this particular copy of the group state.</li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-14"><a class="header" href="#authentication-14">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h4 id="future-work-base-user-secret-rotation"><a class="header" href="#future-work-base-user-secret-rotation">Future work: Base user secret rotation</a></h4>
<ul>
<li>Although the group secret should provide sufficient PCS guarantees after a client removal, users should also be able to rotate their base user secret.</li>
<li>This is tricky, because a rotation would affect all groups simultaneously.</li>
</ul>
<h3 id="join-group-with-new-client"><a class="header" href="#join-group-with-new-client">Join group with new client</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_JOIN_GROUP</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct JoinGroupParams {
  external_commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
}

struct JoinGroupParamsAad {
  existing_user_clients: Vec&lt;LeafIndex&gt;,
  encrypted_credential_information: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The DS verifies that the <code>existing_user_clients</code> correspond to the leaf indices in the user profile of the sending user (identified via the UserKeyHash used for authentication)</li>
<li>An adversary could make the state of clients and DS diverge if it has two users in a group and sends the commit with a client of one user while using the user auth key of the other. The existing_user_clients allows other group members to verify that the adder didn't falsely claim to be another user towards the DS. If the adder did indeed misbehave, other group members can rectify the error as described <a href="spec/./delivery_service/broken_state_detection.html">here</a>.</li>
</ul>
<h4 id="authentication-15"><a class="header" href="#authentication-15">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h3 id="join-connection-group"><a class="header" href="#join-connection-group">Join connection group</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_JOIN_CONNECTION_GROUP</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct JoinConnectionGroupParams {
  external_commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
}

struct JoinConnectionGroupParamsAad {
  encrypted_credential_information: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The DS checks if the group contains the <a href="spec/glossary.html#connectiongroup-extension">connection group extension</a>. This endpoint must only be used to join connection groups.</li>
</ul>
<h4 id="authentication-16"><a class="header" href="#authentication-16">Authentication</a></h4>
<p>No additional authentication is required for this endpoint. The knowledge of the group's EAR key effectively authenticates the joining client.</p>
<h3 id="add-own-clients"><a class="header" href="#add-own-clients">Add own clients</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_ADD_CLIENTS</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AddClientsParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
  welcome: Welcome,
  welcome_attribution_info: WelcomeAttributionInfo,
}

struct AddClientsParamsAad {
  encrypted_credential_information: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The commit must contain exclusively Add proposals</li>
<li>This endpoint brings the same potential to break the group state as the &quot;Join with new client&quot; endpoint. See there for more information.</li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
<li>It also sends <a href="spec/./glossary.html#welcomebundle">WelcomeBundles</a> to the newly added clients.</li>
</ul>
<h4 id="authentication-17"><a class="header" href="#authentication-17">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h3 id="remove-own-clients"><a class="header" href="#remove-own-clients">Remove own clients</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_REMOVE_CLIENTS</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RemoveClientsParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
  user_auth_key: UserAuthKey,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The commit must exclusively contain Remove proposals</li>
<li>The DS validates the commit and updates its public tree</li>
<li>The DS removes the encrypted credential information of all of removed clients</li>
<li>Note, that a user can't remove itself due to MLS constraints</li>
<li>The DS replaces the user auth key of the sender's user profile with the <code>user_auth_key</code></li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-18"><a class="header" href="#authentication-18">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h3 id="resync"><a class="header" href="#resync">ReSync</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_RESYNC_CLIENT</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ResyncClientParams {
  external_commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The commit must contain exactly one Add and one Remove proposal referencing the same leaf</li>
<li>The DS validates the commit and updates its public tree</li>
<li>The leaf credential of the resynced client must remain the same</li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-19"><a class="header" href="#authentication-19">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h3 id="client-self-remove"><a class="header" href="#client-self-remove">Client self remove</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_SELF_REMOVE_CLIENT</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SelfRemoveClientParams {
  remove_proposal: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The proposal must be a Remove proposal for the sending client</li>
<li>The sending client must not be the last client of the user</li>
<li>The DS validates the proposal and stores it in this epoch's proposal store</li>
<li>Finally, the DS sends the <code>remove_proposal</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-20"><a class="header" href="#authentication-20">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h3 id="user-self-remove"><a class="header" href="#user-self-remove">User self remove</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_SELF_REMOVE_USER</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SelfRemoveUserParams {
  remove_proposals: Vec&lt;MlsMessage&gt;,
  group_state_ear_key: GroupStateEarKey,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The proposals must be a Remove proposals for all clients of the user</li>
<li>The DS validates the proposals and stores them in this epoch's proposal store</li>
<li>Finally, the DS sends the <code>remove_proposals</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
<li>Once the proposals are committed, the DS performs the same clean up as for the Remove User endpoint</li>
</ul>
<h4 id="authentication-21"><a class="header" href="#authentication-21">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h4 id="future-work-batch-remove-proposals"><a class="header" href="#future-work-batch-remove-proposals">Future work: Batch remove proposals</a></h4>
<p>With multiple individual proposals all parties have to verify multiple signatures. Ideally, it would be possible to batch remove proposals such that multiple clients can be removed with one proposal. This would require a custom proposal type on the level of MLS.</p>
<h3 id="send-application-message"><a class="header" href="#send-application-message">Send application message</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_SEND_MESSAGE</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SendMessageParams {
  application_message: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The DS sends the <code>application_message</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-22"><a class="header" href="#authentication-22">Authentication</a></h4>
<ul>
<li>SenderId: LeafIndex</li>
</ul>
<h3 id="delete-group"><a class="header" href="#delete-group">Delete group</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_DELETE_GROUP</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DeleteGroupParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>The commit must contain Remove proposals for all group members except for the sending client</li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
<li>After sending out the commit, the DS deletes the group state.</li>
</ul>
<h4 id="authentication-23"><a class="header" href="#authentication-23">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h4 id="future-work-more-efficient-group-deletion"><a class="header" href="#future-work-more-efficient-group-deletion">Future work: More efficient group deletion</a></h4>
<p>It might be nice to just commit to a message that indicates deletion of the group. Alternatively, one could use a batch remove proposal as mentioned <a href="spec/delivery_service.html#future-work-batch-remove-proposals">here</a>.</p>
<h2 id="ds-induced-removals"><a class="header" href="#ds-induced-removals">DS-induced removals</a></h2>
<p>In some situations, the DS will mandate the removal of a given group user by adding a remove proposal to the group's <a href="spec/delivery_service.html#proposal-store">proposal store</a>. Every time, a group state is EAR-decrypted during to process a request, the DS performs the following operations:</p>
<p>Activity time: If the activity time of one of the clients indicates that the client has passed the maximal duration of client commit inactivity, the DS sends a <code>ClientInactivityRemoval</code> to all group members that proposes the removal of all clients that have passed that duration. It also puts the Proposals into the <code>proposal_store</code> of the group.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientInactivityRemoval {
  proposals: Vec&lt;MlsMessage&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>Removed queues: If the <code>sealed_queue_configs</code> vector in the <code>GroupStateDbEntry</code> is non-empty, the DS searches the <code>ClientQueueConfig</code>s of all clients for matching <code>SealedQueueConfig</code>s and distributes the following to all group members for each match. It also puts the Proposals into the <code>proposal_store</code> of the group.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QueueDeletionRemoval {
  proposals: Vec&lt;MlsMessage&gt;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="future-work-removal-due-to-client-misbehaviour"><a class="header" href="#future-work-removal-due-to-client-misbehaviour">Future work: Removal due to client misbehaviour</a></h3>
<p>See <a href="spec/./delivery_service/broken_state_detection.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="group-state-encryption"><a class="header" href="#group-state-encryption">Group state encryption</a></h1>
<p>Generally, the DS encrypts group state at rest, such that only a group ID and a time stamp are stored in plaintext.</p>
<p>Parts of the group state are additionally encrypted such that they are only readable by group members.</p>
<h2 id="encryption-at-rest-ear"><a class="header" href="#encryption-at-rest-ear">Encryption at rest (EAR)</a></h2>
<p>With each group operation request, clients include the group's EAR key, which allows the DS to decrypt the group state, perform the group operation and re-encrypt the group state afterwards.</p>
<p>A group's EAR key is freshly sampled at the group's inception and is not rotated until the group is deleted.</p>
<ul>
<li>Clients send the key to the server for each operation</li>
<li>The key is used to encrypt the whole group state</li>
<li>The client creating the group samples the key freshly upon group creation</li>
<li>Clients joining the group receive the key encrypted via a group info extension (i.e. either via a Welcome or via an External Init package)</li>
<li>The key is fixed and is never rotated</li>
<li>Future work: The key should be rotated (see below)</li>
</ul>
<h2 id="credential-encryption"><a class="header" href="#credential-encryption">Credential encryption</a></h2>
<ul>
<li>Clients hold a Credentials Encryption Base Key (only known to clients)</li>
<li>Used to encrypt and decrypt credential chains</li>
<li>The client creating the group samples the key freshly upon group creation</li>
<li>Clients joining the group receive the key encrypted via a group info extension (i.e. either via a Welcome or via an External Init package)</li>
<li>The key is fixed and is never rotated</li>
<li>Future work: The key should be rotated (see below)</li>
</ul>
<h2 id="future-work-key-rotating-encryption"><a class="header" href="#future-work-key-rotating-encryption">Future work: Key rotating encryption</a></h2>
<p>This scheme allows the simultaneous use of two secrets for decryption, such that two keys are always valid at a time. The use of two valid keys at a time allows the rotation of keys in a fixed interval.</p>
<ul>
<li>The keys used in this scheme are not directly used for encryption. Instead, they act as a base secret from which sender and receiver derive a key ID and the encryption/decryption key. When encrypting, the cipertext is tagged with the key ID.</li>
<li>A key also has a lifetime known to sender and receiver.</li>
<li>The sender derives from the base secret and encrypts the payload.</li>
<li>Before decryption, the recipient derives from the base secret and checks if the key ID matches the one the ciphertext is tagged with.</li>
<li>Once the key has reached its lifetime, the sender samples a new base key and encrypts a copy of it under the old base key.</li>
<li>From now on, the sender always uses the new base key for encryption and attaches the encrypted key to ciphertexts (in addition to the key ID)</li>
<li>The recipient can now check based on the ID of the key it holds, as well as that on a given ciphertext (and that on a potential attached encrypted key) if it first needs to decrypt the wrapped key, or if it can simply decrypt the main ciphertext.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-work-broken-state-detection-and-reaction"><a class="header" href="#future-work-broken-state-detection-and-reaction">Future work: Broken state detection and reaction</a></h1>
<p>Clients can provision their own encrypted <a href="spec/delivery_service/../authentication_service/credentials.html#intermediate-client-credentials">credential chain</a> on the DS. If a client provides broken values in this way, users that join the group can't authenticate the client or user, thus effectively breaking group joining. Since the state is encrypted and the DS can't (and shouldn't) learn the plaintext as to not fully identity the user or client, it cannot verify the validity of the encrypted credential chain.</p>
<p>However, other clients can detect broken credential chains of other clients and prove to the DS that an encrypted value is indeed invalid. With such a proof, the DS can allow the removal of the offending user, even if the reporting client is not a client of an admin user.</p>
<h2 id="broken-states-and-hidden-invalid-updates"><a class="header" href="#broken-states-and-hidden-invalid-updates">Broken states and hidden invalid updates</a></h2>
<p>As a general rule, if an Admin breaks the group state in such a way that the DS can't validate, but that all group members can detect, all group members must consider the group closed.</p>
<ul>
<li>Clients can send a valid-looking commit (from the DS' point of view), where the update path includes invalid (encrypted) path secrets for one or more subtrees of the committer's direct path.
<ul>
<li>Proposed mitigation: The affected clients can resync. It's not clear if it makes sense for affected clients to react differently depending on the role of the attacking client.</li>
</ul>
</li>
<li>Clients can upload an encrypted, but broken client credential chain. This will be detected by all other clients. The two sections below propose a detection + reaction strategy, as well as a prevention strategy.</li>
<li>Clients can corrupt the user profile information of the DS when adding new clients, either by Welcome or by External commit(see the &quot;Join group with new client&quot; endpoint description)</li>
</ul>
<h2 id="future-work-stage-1-detection-and-removal-of-the-offending-user"><a class="header" href="#future-work-stage-1-detection-and-removal-of-the-offending-user">Future work (stage 1): Detection and removal of the offending user</a></h2>
<p>One way of dealing with bad updates is to use franking and allow users prove to the DS that a given update to the group state was broken. The DS can then allow ordinary members to remove the member. Note that it's proabably a reasonable trade-off that the identity of the offender is revealed to the DS in the reporting process. However, revealing group secrets is not.</p>
<h2 id="future-work-stage-2-prevention-using-zero-knowledge-proofs"><a class="header" href="#future-work-stage-2-prevention-using-zero-knowledge-proofs">Future work (stage 2): Prevention using Zero-Knowledge Proofs</a></h2>
<p>Better than the detection plus reaction step would be to allow the DS to verify the encrypted credential chain using ZKPs provided by the client.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queuing-service-qs-1"><a class="header" href="#queuing-service-qs-1">Queuing Service (QS)</a></h1>
<p>The main purpose of the queuing service is to store-and-forward messages delivered by the <a href="spec/./delivery_service.html">delivery service</a>, as well as the publication of KeyPackages. In this chapter we discuss the various concepts used by the QS to provide its functionalitites, as well as its individual endpoints.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The store-and-forwards functionality of the QS is designed in such a way that the QS cannot link the state it maintains for each of the homeserver's users with the user's actual identity as maintained by the AS.</p>
<p>To avoid a connection with the user's actual identity, each user has a QS user record with a sub-record for each of the user's clients. The records are created by the user's clients when they register with the AS.</p>
<p>After creation, the user's clients can publish KeyPackages and fetch messages from their queue, as well as rotate the key material used for authentication, or for at-rest encryption of queued messages.</p>
<p>The QS user record also contains the user's <a href="spec/glossary.html#friendship-token">friendship token</a>, which the QS uses to authenticate requests for batches of the user's KeyPackages.</p>
<p>The client-specific records contain the client's fan-out queue (for messages received from a local or a federated DS), as well as the KeyPackages published by the client. See <a href="spec/queuing_service/keypackage_publication.html">here</a> for more information on KeyPackage publication and how unlinkability between a user's real identity and its pseudonym is maintained.</p>
<p>The fan-out queue in turn contains an optional push-token (encrypted at-rest under the owning client's <a href="spec/glossary.html#push">push-token encryption key</a>), as well as key material used for the <a href="spec/queuing_service/queue_encryption.html">queue's at-rest encryption</a>.</p>
<h2 id="qs-state"><a class="header" href="#qs-state">QS state</a></h2>
<p>The QS keeps the following state.</p>
<ul>
<li><strong>QS user records:</strong> Indexed by a <a href="spec/glossary.html#qs-user-id-qsuid">QsUid</a>, each record contains a number of sub fields.
<ul>
<li><strong>QS user record auth key:</strong> <a href="spec/glossary.html#qs-user-record-auth-key">Public signature key</a> used by a user to authenticate itself as the owner of this record.</li>
<li><strong>Friendship token:</strong> Clients have to provide the friendship token to obtain a bundle of KeyPackages for a given user.</li>
<li><strong>Client specific records:</strong> For each of the user's clients, the QS keeps the following state. Indexed by a <a href="spec/glossary.html#qs-client-id-qscid">QsCid</a>.
<ul>
<li><strong>Activity time:</strong> Timestamp indicating the last time a client has fetched messages from the queue.</li>
<li><strong>KeyPackages:</strong> Encrypted KeyPackages, each with an encrypted <a href="spec/./glossary.html#client-credential-chain">client credential chain</a> attached. At least one KeyPackage has to be marked as KeyPackage of last resort.</li>
<li><strong>Public QS client record key:</strong> <a href="spec/glossary.html#qs-client-record-auth-key">Public signature key</a>. Authenticates the owner of this QS client record and authorizes them to dequeue (i.e. fetch and delete) messages in the queue, as well as to change the queue configuration such as the authentication keys, or to add entries to the block list. Also authorizes the client to upload KeyPackages.</li>
<li><strong>Optional push token:</strong> The client's (optional) push token, stored encrypted at rest under the client's push token encryption key. Used by the QS to create a push notification for the client if a message is enqueued that includes the required encryption key.</li>
<li><strong>Fan-out queue:</strong> A fan-out queue with a number of further record fields attached.
<ul>
<li><strong>Queue encryption key material:</strong> Key material to perform <a href="spec/./queuing_service/queue_encryption.html">queue encryption</a>.
<ul>
<li><strong>Queue encryption key:</strong> <a href="spec/glossary.html#queue-encryption-key">HPKE public key</a> of the queue owner.</li>
<li><strong>Encryption ratchet key:</strong> Symmetric key used to derive queue encryption keys.</li>
</ul>
</li>
<li><strong>Current sequence number:</strong> The current message sequence number.</li>
<li><strong>Queued messages:</strong> A sequence of ciphertexts containing the messages in the queue. Each incoming message is <a href="spec/./queuing_service/queue_encryption.html">encrypted</a> and is assigned the current sequence number, after which the current sequence number is incremented..</li>
<li><strong>Blocklist salt:</strong> Salt that is used when hashing values for the <em>Group blocklist</em>. Generated randomly by the QS upon queue creation.</li>
<li><strong>Blocklist:</strong> List of salted group ID hashes that the QS should not accept messages from for this queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Queue ID encryption keypair:</strong> <a href="spec/glossary.html#queueconfig-encryption-key">A public/private HPKE keypair</a> that clients can encrypt their queue ID under before providing it to a local or federated DS.</li>
<li><strong>QS signing key:</strong> <a href="spec/./glossary.html#qs-signing-key">A public/private signature keypair</a> that the QS uses to sign KeyPackage bundles before returning them upon request. Also used to sign messages when forwarding them from the local DS to a remote QS.</li>
<li><strong>QS-to-QS queues:</strong> A database of queues indexed by the remote QS' domain. Each queue has the same queue encryption key material attached as the client queues.</li>
</ul>
<h2 id="qs-configuration-options"><a class="header" href="#qs-configuration-options">QS configuration options</a></h2>
<ul>
<li>Maximal InterQsAuthToken age: Maximal age of an <a href="spec/./queuing_service.html#inter-qs-authentication">InterQsAuthToken</a> presented to the QS for inter-QS authentication.
<ul>
<li>Default: 1h</li>
</ul>
</li>
<li>Maximal QS client record age: Maximal age of an inactive QS client record.
<ul>
<li>Default: 90d</li>
</ul>
</li>
<li>Maximal number of requested messages: Maximal number of messages that will be returned to a client requesting messages from a queue.
<ul>
<li>Default: 500</li>
</ul>
</li>
<li>Ratchet key rotation interval: Interval in which queue encryption ratchet keys are rotated. See <a href="spec/queuing_service/queue_encryption.html">here</a> for more details on queue encryption.</li>
<li>Maximal number of QS client records per user
<ul>
<li>Default: 10</li>
</ul>
</li>
</ul>
<h2 id="authentication-24"><a class="header" href="#authentication-24">Authentication</a></h2>
<p>Messages from the client to the QS are authenticated by the client by providing an QSAuthToken, where the QsSenderId in the token depends on the endpoint the client is querying.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum QsSenderId {
  QsUid(QsUid),
  QsCid(QsCid),
}

struct QsAuthToken {
  sender_id: QsSenderId,
  timestamp: Timestamp,
  // TBS: sender_id and timestamp
  signature: Signature,
}
<span class="boring">}
</span></code></pre></pre>
<p>The verification key used to create the token depends on the sender_id:</p>
<ul>
<li>QsUid: <a href="spec/./glossary.html#qs-user-record-auth-key">QS user record auth key</a></li>
<li>QsCid: <a href="spec/./glossary.html#qs-client-record-auth-key">QS QS client record auth key</a></li>
</ul>
<h2 id="work-in-progress-federation-endpoints"><a class="header" href="#work-in-progress-federation-endpoints">Work in progress: Federation endpoints</a></h2>
<p>Endpoints publicly accessible and meant to be accessed by federated homeservers.</p>
<h3 id="fetch-qs-signing-key"><a class="header" href="#fetch-qs-signing-key">Fetch QS signing key</a></h3>
<p>A DS or QS can fetch the <a href="spec/./glossary.html#qs-signing-key">QS' signing key</a> through this endpoint.</p>
<h3 id="federated-enqueue-message"><a class="header" href="#federated-enqueue-message">Federated enqueue message</a></h3>
<p>This endpoint allows a remote QS to enqueue a <a href="spec/glossary.html#fan-out-message">fan-out message</a>.</p>
<p>The (receiving) QS decrypts the ciphertext and checks if the QS client record exists. If it doesn't, it responds to the sending QS with the following message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QueueDeleted {
  client_queue_config: ClientQueueConfig,
  group_id: GroupId,
}
<span class="boring">}
</span></code></pre></pre>
<p>If the QS client record exists, the QS checks if the group ID given in the message is in the blocklist of the associated queue. If it isn't, the QS enqueues the message.</p>
<h4 id="inter-qs-authentication"><a class="header" href="#inter-qs-authentication">Inter-QS Authentication</a></h4>
<p>For each query the sending QS has to provide an InterQsAuthToken signed with its QS signing key.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct InterQsAuthToken {
  timetamp: Timestamp,
  // TBS: timestamp
  signature: Signature,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="client-endpoints-1"><a class="header" href="#client-endpoints-1">Client endpoints</a></h2>
<p>Endpoints accessible to clients of the homeserver via HTTP requests.</p>
<h3 id="fetch-queue-config-encryption-key"><a class="header" href="#fetch-queue-config-encryption-key">Fetch queue config encryption key</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_QC_ENCRYPTION_KEY</code></li>
</ul>
<p>Clients can fetch the QS' <a href="spec/./glossary.html#queueconfig-encryption-key">queue config encryption key</a> through this endpoint.</p>
<h3 id="user-record-management-endpoints"><a class="header" href="#user-record-management-endpoints">User record management endpoints</a></h3>
<p>Endpoints for management of QS user records. Note that a QS user record is deleted with its last QS client record.</p>
<h4 id="create-new-qs-user-record"><a class="header" href="#create-new-qs-user-record">Create new QS user record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_CREATE_USER_RECORD</code></li>
</ul>
<p>Create a new QS user record, as well as a first QS client record.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateUserRecordParams {
  user_record_auth_key: SignaturePublicKey,
  friendship_token: FriendshipToken,
  client_record_auth_key: SignaturePublicKey,
  queue_encryption_key: HpkePublicKey,
}
<span class="boring">}
</span></code></pre></pre>
<p>The QS creates the QS user record and QS client record, indexed by a freshly sampled QsUid and QsCid. The QS returns the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateUserRecordResponse {
  qs_uid: QsUid,
  qs_cid: QsCid,
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="edit-qs-user-record"><a class="header" href="#edit-qs-user-record">Edit QS user record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_EDIT_USER_RECORD</code></li>
</ul>
<p>Edit a given QS user record, overwriting the existing values with the one given in the message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct EditUserRecordParams {
  qs_uid: QsUid,
  user_record_auth_key: SignaturePublicKey,
  friendship_token: FriendshipToken,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="authentication-25"><a class="header" href="#authentication-25">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h4 id="get-own-qs-user-record"><a class="header" href="#get-own-qs-user-record">Get own QS user record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_USER_RECORD</code></li>
</ul>
<p>Get the data associated with a given QS user record that you own.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserRecordParams {
  qs_uid: QsUid,
}
<span class="boring">}
</span></code></pre></pre>
<p>The QS returns the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserRecordResponse {
  user_record_auth_key: SignaturePublicKey,
  friendship_token: FriendshipToken,
  client_records: Vec&lt;ClientRecordResponse&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="authentication-26"><a class="header" href="#authentication-26">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h4 id="delete-qs-user-record"><a class="header" href="#delete-qs-user-record">Delete QS user record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_DELETE_USER_RECORD</code></li>
</ul>
<p>Delete the given QS user record including all associated QS client records.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DeleteUserRecordParams {
  qs_uid: QsUid,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="authentication-27"><a class="header" href="#authentication-27">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h5 id="future-work-mfa-for-user-or-qs-client-record-deletion"><a class="header" href="#future-work-mfa-for-user-or-qs-client-record-deletion">Future work: MFA for user or QS client record deletion</a></h5>
<p>User and client deletion are very destructive operations. We should probably require MFA for the associated operations.</p>
<h3 id="client-record-management"><a class="header" href="#client-record-management">Client record management</a></h3>
<h4 id="create-new-qs-client-record"><a class="header" href="#create-new-qs-client-record">Create new QS client record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_CREATE_CLIENT_RECORD</code></li>
</ul>
<p>Create a new QS client record with the given data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateClientRecordParams {
  client_record_auth_key: SignaturePublicKey,
  queue_encryption_key: HpkePublicKey,
}
<span class="boring">}
</span></code></pre></pre>
<p>The QS creates the record indexed by a freshly sampled QsCid and returns the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateClientRecordResponse {
  qs_cid: QsCid,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="authentication-28"><a class="header" href="#authentication-28">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h4 id="edit-qs-client-record"><a class="header" href="#edit-qs-client-record">Edit QS client record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_UPDATE_CLIENT_RECORD</code></li>
</ul>
<p>Overwrite the data of the QS client record with the given QsCid with the given data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct EditClientRecordParams {
  qs_cid: QsCid,
  client_record_auth_key: SignaturePublicKey,
  queue_encryption_key: HpkePublicKey,
  blocklist_entries: Vec&lt;GroupId&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="authentication-29"><a class="header" href="#authentication-29">Authentication</a></h5>
<ul>
<li>QsSenderId: QsCid</li>
</ul>
<h4 id="get-qs-client-record"><a class="header" href="#get-qs-client-record">Get QS client record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_CLIENT_RECORD</code></li>
</ul>
<p>Get the data associated with the QS client record with the given QsCid.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientRecordParams {
  qs_cid: QsCid,
}
<span class="boring">}
</span></code></pre></pre>
<p>The QS returns the following data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientRecordResponse {
  client_record_auth_key: SignaturePublicKey,
  queue_encryption_key: HpkePublicKey,
  blocklist_entries: Vec&lt;GroupId&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="authentication-30"><a class="header" href="#authentication-30">Authentication</a></h5>
<ul>
<li>QsSenderId: QsCid</li>
</ul>
<h4 id="delete-qs-client-record"><a class="header" href="#delete-qs-client-record">Delete QS client record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_DELETE_CLIENT_RECORD</code></li>
</ul>
<p>Delete the QS client record with the given QsCid if it is not the user's last QS client record. The last client in a QS user record can only be deleted by deleting the QS user record itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DeleteClientRecordParams {
  qs_cid: QsCid,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="authentication-31"><a class="header" href="#authentication-31">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h4 id="publish-keypackages"><a class="header" href="#publish-keypackages">Publish KeyPackages</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_PUBLISH_KEY_PACKAGES</code></li>
</ul>
<p>Publish the given <a href="spec/glossary.html#addpackage">AddPackage</a> under the given QsCid.</p>
<p>All of the KeyPackages contained in the AddPackages have to contain a <a href="spec/glossary.html#queueconfig-extension">QueueConfigExtension</a> and at least one of the AddPackage has to contain a KeyPackage marked as <a href="spec/glossary.html#last-resort-extension">KeyPackage of last resort</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PublishKeyPackagesParams {
  qs_cid: QsCid,
  add_packages: Vec&lt;AddPackage&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The QS deletes all existing KeyPackages before publishing the new ones.</p>
<h5 id="authentication-32"><a class="header" href="#authentication-32">Authentication</a></h5>
<ul>
<li>QsSenderId: QsCid</li>
</ul>
<h5 id="future-work-allow-more-granular-keypackage-rotation"><a class="header" href="#future-work-allow-more-granular-keypackage-rotation">Future work: Allow more granular KeyPackage rotation</a></h5>
<p>Throwing all KeyPackages away regardless of their remaining validity is a bit wasteful. A client should have more granular control over which KeyPackages it wants to remain on the QS.</p>
<h5 id="future-work-more-than-one-last-resort-keypackage"><a class="header" href="#future-work-more-than-one-last-resort-keypackage">Future work: More than one last-resort KeyPackage</a></h5>
<p>Using the same KeyPackage of last resort in multiple groups can allow a federated DS to track the user across these groups. This could be mitigated somewhat by having multiple KeyPackages of last resort that the QS can cycle through when there are no other KeyPackages left.</p>
<h4 id="get-client-keypackage"><a class="header" href="#get-client-keypackage">Get client KeyPackage</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_CLIENT_KEY_PACKAGE</code></li>
</ul>
<p>Get the KeyPackage of the client with the given QsCid. This allows clients of a user to fetch individual AddPackages for other clients of the same user. These individual AddPackages are required to add new clients to existing groups.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientKeyPackageParams {
  qs_cid: QsCid,
}
<span class="boring">}
</span></code></pre></pre>
<p>The QS returns one of the client's AddPackages and deletes the AddPackage afterwards (except if it contains a KeyPackage of last resort.)</p>
<h5 id="authentication-33"><a class="header" href="#authentication-33">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h4 id="get-keypackage-batch"><a class="header" href="#get-keypackage-batch">Get KeyPackage batch</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_KEY_PACKAGE_BATCH</code></li>
</ul>
<p>Get a <a href="spec/glossary.html#user-keypackage-batch">KeyPackageBatch</a> of the user with the given friendship token.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct KeyPackageBatchParams {
  friendship_token: FriendshipToken,
}
<span class="boring">}
</span></code></pre></pre>
<p>The QS checks if there is a QS user record with the given <a href="spec/glossary.html#friendship-token">FriendshipToken</a> and returns a <a href="spec/glossary.html#addpackage">AddPackage</a> of each of the matching user's clients, along with a signed <a href="spec/glossary.html#user-keypackage-batch">KeyPackageBatch</a> that includes a current time stamp and the references of the returned KeyPackages.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct KeyPackageBatchResponse {
  add_packages: Vec&lt;AddPackage&gt;,
  key_package_batch: KeyPackageBatch,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="authentication-34"><a class="header" href="#authentication-34">Authentication</a></h5>
<p>Instead of a QSAuthToken, the QS requires the client to provide a friendship token. If the token matches the one in the QS user record, the query is considered valid.</p>
<h4 id="dequeue-messages-1"><a class="header" href="#dequeue-messages-1">Dequeue messages</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_DEQUEUE_MESSAGES</code></li>
</ul>
<p>Dequeue messages from a queue, starting with the message with the given sequence number.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DequeueMessagesParams {
  qs_cid: QsCid,
  sequence_number_start: u64,
  max_message_number: u64,
}
<span class="boring">}
</span></code></pre></pre>
<p>The QS deletes messages older than the given sequence number and returns messages starting with the given sequence number. The maximum number of messages returned this way is the smallest of the following values.</p>
<ul>
<li>The number of messages remaining in the queue</li>
<li>The value of the <code>max_message_number</code> field in the request</li>
<li>The QS configured maximum number of returned messages</li>
</ul>
<h5 id="authentication-35"><a class="header" href="#authentication-35">Authentication</a></h5>
<ul>
<li>QsSenderId: QsCid</li>
</ul>
<h4 id="negotiate-websocket-connection"><a class="header" href="#negotiate-websocket-connection">Negotiate websocket connection</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_WS</code></li>
</ul>
<p>Allows a client to create a websocket connection with the QS. If such a websocket connection exists then whenever the QS would send a push notification, it instead signals the client via the websocket connection.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WsParams {
  qs_cid: QsCid,
}
<span class="boring">}
</span></code></pre></pre>
<h5 id="authentication-36"><a class="header" href="#authentication-36">Authentication</a></h5>
<ul>
<li>QsSenderId: QsCid</li>
</ul>
<h2 id="local-homeserver-endpoints"><a class="header" href="#local-homeserver-endpoints">Local homeserver endpoints</a></h2>
<p>Endpoints that are accessible by other services of the local homeserver. There is no authentication on these endpoints, as we assume that the infrastructure running the services provides sufficient access control.</p>
<h3 id="local-enqueue-message"><a class="header" href="#local-enqueue-message">Local enqueue message</a></h3>
<p>Receive a <a href="spec/glossary.html#fan-out-message">fan-out-message</a> to store-and-forward to local clients with the specified ClientQueueConfigs.</p>
<p>The QS checks the <code>client_homeserver_domain</code> in the <code>client_queue_config</code>. If it is the homeserver's own domain, the QS decrypts the ciphertext and checks if the group ID given in the message is in the queue's blocklist. If it isn't, it enqueues the message.</p>
<p>If the domain is not the homerserver's own domain, the QS calls the <a href="spec/queuing_service.html#federated-enqueue-message">federated enqueue message</a> endpoint of the QS of the corresponding domain.</p>
<p>If the QS learns that a message couldn't be delivered due to a missing queue, either because a local lookup has failed, or due to a response from a federated QS, it reports the <code>client_queue_config</code> and the group ID back to the DS via a <a href="spec/queuing_service.html#federated-enqueue-message">QueueDeleted</a> message.</p>
<h4 id="future-work-persist-and-ear-encrypt-federated-messages"><a class="header" href="#future-work-persist-and-ear-encrypt-federated-messages">Future work: Persist and EAR encrypt federated messages</a></h4>
<p>We can't expect federated homeservers to be online all the time. Instead of sending the messages immediately, they should be stored-and-forwarded via a queue and encrypted-at-rest in the same way as with client queues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="queue-encryption"><a class="header" href="#queue-encryption">Queue encryption</a></h1>
<p>Messages in queues contain metadata such as epochs, group IDs and explicit changes to group states (although all based on pseudonymous identities). To protect this metadata against state-leakages, messages in queues are stored encrypted in such a way that only the client owning the queue can decrypt the messages.</p>
<p>Since state-leakage (i.e. state compromise) is the threat model, the encryption protocol provides forward secrecy and post-compromise security.</p>
<h2 id="key-ratcheting"><a class="header" href="#key-ratcheting">Key ratcheting</a></h2>
<p>Upon creation of a QS QS client record, the creator provides a <a href="spec/queuing_service/../glossary.html#queue-encryption-key">queue encryption key</a> which the QS stores alongside the queue. The QS then samples a random string as the initial ratchet key, stores a copy and encrypts another copy under the queue encryption key. The resulting ciphertexts is enqueued like regular messages.</p>
<p>Whenever the QS enqueues a message, it first uses the ratchet key to derive two keys using distinct labels: The next ratchet key and a message encryption key. The message encryption key is used to encrypt the message before tagging it with the current sequence number (and advancing the currently stored sequence number) and enqueuing it. The next ratchet key is stored in place of the old ratchet key (which is deleted after use, along with the message encryption key). This process is repeated with every message to be enqueued.</p>
<p>The ratcheting of encryption keys (and the deletion of keys after use) provides forward secrecy.</p>
<p>The client fetching the queue for the first time first decrypts the ratchet key. For each message it fetches from the queue, the client follows the same derivation steps as the QS and decrypts the fetched messages.</p>
<h2 id="key-updates"><a class="header" href="#key-updates">Key updates</a></h2>
<p>To achieve post-compromise security, the ratchet keys must be periodically injected with fresh randomness. The frequency with which this happens can be configured via the <a href="spec/queuing_service/../queuing_service.html#qs-configuration-options">QS configuration options</a>. The injected randomness must be encrypted and sent to the owner of the QS QS client record, so the frequency with which the keys are rotated represents a balance between security and performance.</p>
<p>Whenever the ratchet key should be refreshed, the QS derives a rotation key from the current ratchet key. The QS then derives a new ratchet key from the rotation key and some fresh randomness. The QS then encrypts the injected randomness under the queue encryption key. The encrypted randomness is then tagged with the current sequence number and enqueued like a regular message. The new ratchet key then replaces the old ratchet key.</p>
<p>When dequeuing such an encrypted key update, the client decrypts the update and follows the same derivation steps as the QS to obtain the fresh ratchet key.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="friendship-tokens-and-keypackage-publication"><a class="header" href="#friendship-tokens-and-keypackage-publication">Friendship tokens and KeyPackage publication</a></h1>
<p>To prevent a homeserver from learning which groups a user is a member of, the user's information on the QS and DS are pseudonymous. However, other users must be able to authenticate the user when one of the user's clients joins a group. This would typically happen through the Credential in a client's KeyPackage. However, since the KeyPackages are published on the QS and the public trees to which the KeyPackages are added are observable by the DS.</p>
<p>The goal of this mechanism is thus to protect the unlinkability between the user's pseudonymous identity (i.e. the QS user record and the user's user and client profiles on the local DS) and the user's actual identity against a malicious homeserver.</p>
<p>The mechanism outlined in this section does not protect against the use of traffic pattern analysis. However, it can be used in conjunction with an onion routing system or a mixnet.</p>
<h2 id="friendship-keys-and-credential-encryption"><a class="header" href="#friendship-keys-and-credential-encryption">Friendship keys and credential encryption</a></h2>
<p>When establishing a <a href="spec/queuing_service/../authentication_service/connection_establishment.html">connection with another user</a>, the users exchange <a href="spec/queuing_service/../glossary.html#friendship-keys">friendship keys</a>. This set of keys includes a friendship encryption key and a friendship token. Both keys are used in the context of KeyPackage publishing.</p>
<p>Possession of a friendship token authorizes a client to add the original owner of the token to a group. Once added to a group, all group members must be able to authenticate the newly added user and its clients.</p>
<p>However, the QS that stores the published KeyPackages that facilitate group member additions must not learn the user's identity. Thus, KeyPackages are always published as <a href="spec/queuing_service/../glossary.html#addpackage">AddPackages</a>, where the KeyPackage only contains a pseudonymous <a href="spec/queuing_service/../authentication_service/credentials.html#leaf-credentials">Leaf Credential</a> and the <a href="spec/queuing_service/../authentication_service/credentials.html#intermediate-client-credentials">intermediate client credential</a> that links the pseudonymous credential with the client's <a href="spec/queuing_service/../authentication_service/credentials.html#client-credentials">Client Credential</a> is encrypted under the friendship encryption key.</p>
<p>After retrieving such a AddPackage (as part of a <a href="spec/queuing_service/../glossary.html#user-keypackage-batch">KeyPackageBatch</a>), the adding client first decrypts the encrypted intermediate client credential and verifies that the <a href="spec/queuing_service/../glossary.html#client-credential-chain">credential chain</a> is correct. If this is the case, the client re-encrypts the intermediate client credential under the target group's <a href="spec/queuing_service/../delivery_service/group_state_encryption.html">credential encryption key</a> before performing the actual addition.</p>
<p>Members of the group can now decrypt the intermediate client credential and authenticate the user.</p>
<p>Note that neither DS nor QS are in possession of either the friendship encryption key or the credential encryption key. Both QS and DS store the intermediate client credential exclusively as ciphertexts.</p>
<h2 id="welcome-attribution"><a class="header" href="#welcome-attribution">Welcome attribution</a></h2>
<p>The friendship encryption key is also used to allow the recipient of a Welcome message to quickly authenticate the sender while hiding the sender's identity from the DS and QS involved.</p>
<p>In particular, instead of a plain MLS Welcome message, new joiners receive a <a href="spec/queuing_service/../glossary.html#welcomebundle">WelcomeBundle</a>, which (along with the Welcome and some other data) contains a <a href="spec/queuing_service/../glossary.html#welcome-attribution-info">WelcomeAttributionInfo</a>. The WelcomeAttributionInfo in turn contains the senders <a href="spec/queuing_service/../glossary.html#client-id-cid">client ID</a> and is signed by the sender's <a href="spec/queuing_service/../authentication_service/credentials.html#client-credentials">Client Credential</a>. The recipient of the WelcomeBundle can thus identify and authenticate the sender without retrieving the group's public tree first.</p>
<p>However, to avoid accumulation of metadata, the sender's identity must be hidden from both DS and QS. This is achieved by encrypting the WelcomeAttributionInfo in the WelcomeBundle using the recipient's friendship encryption key.</p>
<h2 id="friendship-token-rotation"><a class="header" href="#friendship-token-rotation">Friendship token rotation</a></h2>
<p>A user must rotate its friendship token when removing the connection with another user. The token is rotated by sampling a fresh, random token and replacing the old token on the QS. After replacing the token on the QS, the user must broadcast the new token to the rest of its own clients, as well as all users with which the user wishes to keep a connection.</p>
<h3 id="future-work-friendship-encryption-key-rotation"><a class="header" href="#future-work-friendship-encryption-key-rotation">Future work: Friendship encryption key rotation</a></h3>
<p>It should also be possible to rotate the friendship encryption key.</p>
<p>Rotating the friendship encryption key can lead to annoying race conditions (e.g. a Welcome sent shortly before the key was rotated). If we want to rotate it, we could use key ids (see <a href="spec/queuing_service/./delivery_service/group_state_encryption.html">here</a>) and a grace period before an old key is not accepted anymore.</p>
<h3 id="future-work-replace-the-friendship-token"><a class="header" href="#future-work-replace-the-friendship-token">Future work: Replace the friendship token</a></h3>
<p>It is conceivable that the frienship token can be replaced with a better mechanism that allows for easier rotation. It is conceivable that puncturable signatures or blocklistable anonymous credentials could be useful here.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="work-in-progress-client-state"><a class="header" href="#work-in-progress-client-state">Work in progress: Client state</a></h1>
<p>The documentation of the individual endpoints describes most of the behaviour expected by clients to interact with the homeserver. This chapter documents the state kept by each of a user's clients.</p>
<h2 id="client-state"><a class="header" href="#client-state">Client state</a></h2>
<ul>
<li>Client credential (plus private key)</li>
<li>QS QueueConfig encryption key</li>
<li>AS credential(s)</li>
<li>AS intermediate credential(s)</li>
<li>(Optional) push token and push token encryption key</li>
<li>Own friendship token</li>
<li>Own friendship encryption key</li>
<li>Queue encryption key (plus private key)</li>
<li>Pseudonymous client id</li>
<li>Client record auth key</li>
<li>QS User record auth key</li>
<li>Own AddPackages (and private keys)</li>
<li>Connection establishment KeyPackage (and private keys)</li>
<li>For each group:
<ul>
<li>MLS group state</li>
<li>group state EAR key</li>
<li>credential encryption key</li>
<li>User auth key (plus private key)</li>
<li>Intermediate Client Credential (plus private key)</li>
</ul>
</li>
<li>For each connected user:
<ul>
<li>friendship token</li>
<li>friendship encryption key</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client-synchronization"><a class="header" href="#client-synchronization">Client synchronization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-work"><a class="header" href="#future-work">Future work</a></h1>
<p>This chapter contains ideas and plans that have not yet made it into the specification.</p>
<h2 id="non-pseudonymous-homeservergroups"><a class="header" href="#non-pseudonymous-homeservergroups">Non-pseudonymous homeserver/groups</a></h2>
<p>It could be advantageous to have groups where the homeserver can identify individual members. This would be an option that could either be turned on or off on a homeserver or on a per-group basis. A variety of mechanisms would have to be adjusted for non-pseudonymous groups. It's also a question we want interoperability between pseudonymous and non-pseudonymous homeservers.</p>
<h2 id="plaintext-queue-configs"><a class="header" href="#plaintext-queue-configs">Plaintext queue configs</a></h2>
<p>Currently, all queue configs are <a href="spec/glossary.html#sealed-queue-config">sealed</a>. This is measure to protect metadata is unnecessary in the case the DS and the client's QS are part of the same homeserver. As a result, it should be possible to store the queue config as plaintext in such an instance.</p>
<h2 id="improved-spam-management-for-fan-out-queues"><a class="header" href="#improved-spam-management-for-fan-out-queues">Improved spam management for fan-out queues</a></h2>
<p>Friends of a user can currently invite the user's clients to large, very active groups and thus create a large influx of messages for the user's clients. This can be used to spam the user and there is currently no mitigation other than the use of privacy pass tokens. It would be good to allow the QS to categorize incoming messages into SPAM/HAM messages, where in the background, clients only download HAM messages and wait until the application is in the foreground to retrieve SPAM messages as well. This would also allow other UX modes, where the user has to first actively accept joining a group before the client downloads the corresponding SPAM messages.</p>
<h2 id="tighter-authentication"><a class="header" href="#tighter-authentication">Tighter authentication</a></h2>
<p>The AuthTokens required for client-side authentication by QS and DS prove that the client owns a signature key and are bound losely to the context in which they are used. However, having the signature cover the whole request would provide a tighter bind between authentication and context. One drawback is that we either have to re-serialize the request to sign/verify, or that we have to fix the general request serialization scheme to a deterministic one that accommodates signatures.</p>
<h2 id="re-initialization-of-groups"><a class="header" href="#re-initialization-of-groups">Re-initialization of groups</a></h2>
<p>MLS allows the re-initialization of groups to change ciphersuite or to update the MLS version. We definitely need this sooner or later.</p>
<h2 id="protocol-versioning"><a class="header" href="#protocol-versioning">Protocol versioning</a></h2>
<p>All messages of the homeserver protocol should contain a version number to allow clients and servers to process messages with the right versions. The versions of the protocol supported by a given client should be present in the client's KeyPackage and the version supported by the homeserver should be published in it's .well-known (or similar).</p>
<h2 id="ciphersuite-agility"><a class="header" href="#ciphersuite-agility">Ciphersuite agility</a></h2>
<p>It might be interesting to support ciphersuite agility in a similar way as MLS. An alternative would be to tie the ciphersuites to protocol versions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<h2 id="user-name-un"><a class="header" href="#user-name-un">User Name (UN)</a></h2>
<p>ID of a user consisting of a String qualified with the domain of the user's AS.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserName {
    as_domain: FQDN,
    user_name: String,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="client-id-cid"><a class="header" href="#client-id-cid">Client ID (CID)</a></h2>
<p>ID of a user's client, qualified by the user name of the owner's user.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientId {
    user_id: UserName,
    client_uuid: UUID,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="qs-user-id-qsuid"><a class="header" href="#qs-user-id-qsuid">QS User ID (QsUid)</a></h2>
<p>The ID of a QS user record on the user's QS.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QsUid {
    user_id: UUID,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="qs-client-id-qscid"><a class="header" href="#qs-client-id-qscid">QS client ID (QsCid)</a></h2>
<p>The ID representing a client in the owning user's QS user record.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PseudonymousClientId {
    qs_uid: QsUid,
    client_id: UUID,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="queueconfig-encryption-key"><a class="header" href="#queueconfig-encryption-key">QueueConfig encryption key</a></h2>
<p>A public HPKE key owned by a homeserver's QS. It is used by the homeserver's clients to encrypt their <a href="spec/glossary.html#sealed-queue-config">sealed queue configs</a>. The QS holds the private key so that it can decrypt the sealed queue configs when receiving messages.</p>
<h2 id="sealed-queue-config"><a class="header" href="#sealed-queue-config">Sealed queue config</a></h2>
<p>The sealed queue config is a struct that contains the information required by a DS to deliver messages to a client. In particular, the sealed queue config contains the following data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientQueueConfig {
    client_homeserver_domain: FQDN,
    sealed_config: SealedQueueConfig,
}

struct QueueConfig {
    option_push_token_key: Option&lt;PushTokenEarKey&gt;,
    pseudonymous_client_id: PseudonymousClientId,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>SealedQueueConfig</code> is the client's <code>QueueConfig</code> encrypted using HPKE in the asymmetrically authenticated mode using the <code>QueueConfigEncryptionKey</code> of the client's QS and the client's own <a href="spec/glossary.html#qs-client-record-auth-key">QS QS client record key</a>.</p>
<h2 id="rolesextension"><a class="header" href="#rolesextension">RolesExtension</a></h2>
<p>An MLS group context extension that contains information on the roles of the individual members in a given group. A member's role can be either <em>admin</em> or <em>member</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RolesExtension {
    admins: Vec&lt;LeafIndex&gt;,
    members: Vec&lt;LeafIndex&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>If a user has multiple clients in a given group, all clients of that user MUST have the same role.</p>
<h3 id="future-work-manage-roles-via-proposal"><a class="header" href="#future-work-manage-roles-via-proposal">Future work: Manage roles via proposal</a></h3>
<p>For now, chaning roles requires a GroupContextExtension proposal, which can be expensive if there is more than one extension. Instead it should probably be possible to change roles via a custom proposal.</p>
<h2 id="welcome-attribution-info"><a class="header" href="#welcome-attribution-info">Welcome attribution info</a></h2>
<p>Encrypted under the recipient's friendship encryption key. The TBS has to be signed by the sender's client credential.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WelcomeAttributionInfoPayload {
    sender_client_id: ClientId,
    group_credential_encryption_key: GroupCredentialEarKey,
}

struct WelcomeAttributionInfoTbs {
    payload: WelcomeAttributionInfoPayload,
    group_id: GroupId,
    welcome: Vec&lt;u8&gt;,
}

struct WelcomeAttributionInfo {
    payload: WelcomeAttributionInfoPayload,
    signature: Signature,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="welcomebundle"><a class="header" href="#welcomebundle">WelcomeBundle</a></h2>
<p>A bundle allowing a client to join a new group.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WelcomeBundle {
    welcome: Welcome,
    encrypted_welcome_attribution_info: Vec&lt;u8&gt;,
    encrypted_group_state_ear_key: Vec&lt;u8&gt;,
    group_id: GroupId,
}
<span class="boring">}
</span></code></pre></pre>
<p>The WelcomeAttributionInfo is encrypted under the joining client's friendship encryption key. The group state EAR key is by the DS under the recipient's init key (contained in the recipient's KeyPackage).</p>
<h2 id="user-keypackage-batch"><a class="header" href="#user-keypackage-batch">User KeyPackage batch</a></h2>
<p>When a client retrieves KeyPackages from a QS for a given user, the QS responds with the KeyPackages, the associated Intermediate Client credentials, as well as a KeyPackageBatch.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct KeyPackageBatch {
  key_package_refs: Vec&lt;KeyPackageRef&gt;,
  timestamp: Timestamp,
  signature: Signature,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="addpackage"><a class="header" href="#addpackage">AddPackage</a></h2>
<p>A struct consisting of a KeyPackage and the associated <a href="spec/authentication_service/credentials.html#intermediate-client-credentials">Intermediate Client Credential</a>, where the latter is encrypted under the user's current <a href="spec/glossary.html#friendship-encryption-key">friendship encryption key</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AddPackage {
    key_package: KeyPackage,
    icc_ciphertext: Vec&lt;u8&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="friendship-keys"><a class="header" href="#friendship-keys">Friendship keys</a></h2>
<p>A set of keys known to users that the owning user has a <a href="spec/authentication_service/connection_establishment.html">connection</a> with.</p>
<h3 id="friendship-encryption-key"><a class="header" href="#friendship-encryption-key">Friendship encryption key</a></h3>
<p>A symmetric key used to encrypt the credential information attached to KeyPackages, as well as the WelcomeAttributionInfo. This key is never rotated.</p>
<h4 id="future-work-rotate-friendship-encryption-key"><a class="header" href="#future-work-rotate-friendship-encryption-key">Future work: Rotate friendship encryption key</a></h4>
<p>Rotating the friendship encryption key can lead to annoying race conditions (e.g. a Welcome sent short before the key was rotated). If we want to rotate it, we could use key ids (see <a href="spec/./delivery_service/group_state_encryption.html">here</a>) and a grace period before an old key is not accepted anymore.</p>
<h3 id="friendship-token"><a class="header" href="#friendship-token">Friendship token</a></h3>
<p>A random byte string that is used by users to prove that they have a <a href="spec/authentication_service/connection_establishment.html">connection</a> with the owning user, which in turn allows them to fetch the user's key packages. Can be rotated by the owning user by updating the value on its QS and broadcasting it to all of the user's (remaining) connections.</p>
<h2 id="client-credential-chain"><a class="header" href="#client-credential-chain">Client credential chain</a></h2>
<p>A tuple consisting of an intermediate client credential and a client credential. Used to authenticate individual clients in the context of an MLS group. Stored on the DS encrypted under the group's <a href="spec/delivery_service/group_state_encryption.html">credential encryption key</a>.</p>
<h2 id="queue-encryption-key"><a class="header" href="#queue-encryption-key">Queue encryption key</a></h2>
<p>HPKE public key associated with a client's fan-out or direct queue and used to facilitate <a href="spec/queuing_service/queue_encryption.html">at-rest encryption of messages in the queue</a>.</p>
<h2 id="qs-client-record-auth-key"><a class="header" href="#qs-client-record-auth-key">QS client record auth key</a></h2>
<p>Signature public key associated with a QS QS client record. Used by the QS to authenticate the owning client.</p>
<h2 id="qs-user-record-auth-key"><a class="header" href="#qs-user-record-auth-key">QS user record auth key</a></h2>
<p>Signature public key associated with a QS user record. Used by the QS to authenticate the user's clients.</p>
<h2 id="qs-signing-key"><a class="header" href="#qs-signing-key">QS signing key</a></h2>
<p>Signature key used by federated QS' to authenticate the owning QS, as well as by a local or federated DS to verify signatures on <a href="spec/./glossary.html#user-keypackage-batch">user KeyPackage batches</a>.</p>
<h2 id="fan-out-message"><a class="header" href="#fan-out-message">Fan out message</a></h2>
<p>Message sent from the DS to its local QS, either for forwarding to another QS or for enqueuing into a local queue.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MessageContent {
    Commit(MlsMessage),
    Application(MlsMessage),
    WelcomeBundle(WelcomeBundle),
}

struct FanOutMessage {
    client_queue_configs: Vec&lt;ClientQueueConfig&gt;,
    message_content: MessageContent,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="last-resort-extension"><a class="header" href="#last-resort-extension">Last resort extension</a></h2>
<p>A KeyPackage extension that marks the given KeyPackage as a <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-keypackage-reuse">KeyPackage of last resort</a>.</p>
<h2 id="push-token-encryption-key"><a class="header" href="#push-token-encryption-key">Push-token encryption key</a></h2>
<p>A symmetric encryption key that a client uses to encrypt its push-token on its QS QS client record. It is part of the client's encrypted <a href="spec/glossary.html#sealed-queue-config">QueueConfig</a>.</p>
<h2 id="queueconfig-extension"><a class="header" href="#queueconfig-extension">QueueConfig extension</a></h2>
<p>A KeyPackage extension that contains a client's <a href="spec/glossary.html#sealed-queue-config">ClientQueueConfig</a>. This extension is required for all KeyPackages uploaded to a QS.</p>
<h2 id="connectiongroup-extension"><a class="header" href="#connectiongroup-extension">ConnectionGroup extension</a></h2>
<p>A GroupContext extension that contains no data, but the presence of which in a group indicates that the group is a <a href="spec/authentication_service/connection_establishment.html">connection group</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-in-messaging-applications"><a class="header" href="#authentication-in-messaging-applications">Authentication in messaging applications</a></h1>
<p>All of the commonly used messaging applications aim to provide authentication as one of their primary security guarantees. The goal is that recipients of a given message can authenticate the sender based on (public) cryptographic key material which we call the sender’s <em>cryptographic identity</em> (for brevity sometimes just <em>identity</em>). The cryptographic identity is typically a signature public key or a public key that can be used in an authenticated key exchange. The holder of the corresponding private key material is the owner of the cryptographic identity.</p>
<p>The recipient can use the cryptographic identity of the sender to either authenticate individual messages (e.g. verifying the sender’s signature on an incoming message using the sender’s public signature key) or to establish an authenticated channel to the sender by way of an initial, authenticated key agreement (e.g. a Diffie-Hellman (DH) style key exchange involving the DH public key of both parties). In both cases, the recipient relies on the fact that the cryptographic identity it uses on for authentication is indeed owned by whom the recipient thinks the sender of the message is.</p>
<p>This leads to the question of how the sender and receiver can ensure (or at least increase their confidence) that the cryptographic identity each has of its peer is correct.</p>
<p>The problem is typically solved by the sender and receiver using a trusted channel to either exchange cryptographic identities or verify them later.</p>
<h2 id="meddler-in-the-middle-mitm-attacks"><a class="header" href="#meddler-in-the-middle-mitm-attacks">Meddler-in-the-middle (MITM) attacks</a></h2>
<p>In both cases, the threat is that an adversary, often called a meddler-in-the-middle <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">sits between sender and receiver</a> and controls the channel they use to exchange messages. When the sender and receiver exchange their respective cryptographic identities, the adversary replaces them with ones that it controls. After such an attack, the adversary can impersonate one victim towards the other, as long as sender and receiver use a channel for communication that the adversary controls.</p>
<h1 id="existing-authentication-concepts"><a class="header" href="#existing-authentication-concepts">Existing authentication concepts</a></h1>
<p>There are many methods for the the recipient to ensure (or gain confidence in the fact) that the cryptographic identity it uses to authenticate the sender of a message corresponds to the private key material held by the original sender.</p>
<p>Some of these methods rely on the properties of the channel used to <strong>exchange</strong> the identities and some on additional ways of <strong>verifying</strong> identities after they were exchanged through a channel with limited trust.</p>
<p>The approaches are not mutually exclusive. Typically messaging systems use at least two of the approaches detailed below.</p>
<h2 id="trust-on-first-use-tofu"><a class="header" href="#trust-on-first-use-tofu">Trust on first use (TOFU)</a></h2>
<p>As the name implies, <a href="https://en.wikipedia.org/wiki/Trust_on_first_use">trust on first use</a> means that the receiver trusts the cryptographic identity of the sender upon initial reception, regardless of the transportation channel.</p>
<p><strong>Threat model:</strong> The adversary either controls the channel, but is passive (can observe, but not tamper with traffic) at the time the exchange happens, or controls the general communication channel, but not the one used to exchange identities.</p>
<h2 id="trusted-third-party-exchange"><a class="header" href="#trusted-third-party-exchange">Trusted third party (exchange)</a></h2>
<p>A typical scenario in the messaging world is where the receiver trusts the cryptographic identity of the sender because it received the identity from a <a href="https://en.wikipedia.org/wiki/Trusted_third_party">trusted third party</a> (TTP). This approach only works if there is a designated trusted third party that all participants of the messaging system are either provisioned with in some way or have an authenticated way of retrieving. Typically, TTPs are no regular participants in the messaging system.</p>
<ul>
<li>The receiver could obtain the sender’s identity from the provider of the messaging service, as long as the cryptographic identity of the messaging service itself was provisioned upon downloading and installing the app.</li>
<li>The receiver could obtain the sender’s identity from the sender’s identity provider, as long as it has some way of discovering the address and cryptographic identity of said provider through an authenticated channel.</li>
</ul>
<p><strong>Threat model:</strong> The adversary actively controls the network, but not the trusted third party. The adversary also can’t interfere with the provisioning process.</p>
<h2 id="out-of-band-verification"><a class="header" href="#out-of-band-verification">Out-of-band verification</a></h2>
<p>To establish trust in the validity of the cryptographic identities of the sender, the recipient party can verify via an <a href="https://ssd.eff.org/en/glossary/out-band-verification">out-of-band (OOB) channel</a>.</p>
<ul>
<li>Sender and receiver could meet in the real world and verify their respective cryptographic identities by comparing public keys on their screens, or by scanning a QR code. Note, that this scenario requires both parties to trust their hard- and software (e.g. display drivers) to show the right public key or QR code.</li>
</ul>
<p><strong>Threat model:</strong> The adversary controls the network and in particular the channel (or the third party) used to exchange the identities, but does not control the channel used to verify them.</p>
<h2 id="delegated-verification"><a class="header" href="#delegated-verification">Delegated verification</a></h2>
<p>Instead of performing the verification itself, the receiver can also decide to trust another party to verify the sender’s identity for them. There are several variants of this scenario, although they are all based on the principle of delegated verification or delegated trust.</p>
<h3 id="trusted-third-party-verification"><a class="header" href="#trusted-third-party-verification">Trusted third party (verification)</a></h3>
<p>Similar to the use of TTPs as an authenticated channel to exchange identities, a TTP can also be used to verify a cryptographic identity. As with the use of a TTP for the exchange of identities, the cryptographic identity of the TTP has to be known to all users for this approach to work.</p>
<ul>
<li>Many people use their homepages or social media profiles to publish a fingerprint of their cryptographic identity in one or more messaging apps. As long as the receiver can establish an authenticated channel to the TTP hosting the fingerprint, it can verify the identity.</li>
<li>In the context of the WebPKI, when connecting to a web server via HTTPS, the server sends its certificate and provides a certificate chain from the server certificate to a WebPKI root of trust. The client can now verify the chain up to the root of trust. The certificate authorities that sign server certificates in the root of trust thus act as TTPs for verification.</li>
</ul>
<p><strong>Threat model:</strong> The adversary controls the network and in particular the channel (or the third party) used to exchange the identities, but not the third party that facilitates the verification.</p>
<h3 id="cross-signing-1"><a class="header" href="#cross-signing-1">Cross-signing</a></h3>
<p>Cross-signing is similar to the use of a TTP for verification, except that the parties that cross-sign a cryptographic identity are regular participants of the messaging system. Cross-signing is often used in addition to other authentication mechanisms.</p>
<ul>
<li>Cross-signing is commonly used if a party has multiple clients, each with its own cryptographic identity. In this case, the cryptographic identity of a new client can be cross-signed by an existing one, allowing other parties that have already verified the identity of the cross-signer to also trust in the new client.</li>
</ul>
<p><strong>Threat model:</strong> The adversary controls the network, but does not control the party cross-signing the cryptographic identity in question. The adversary also cannot compromise parties that are trusted to cross-sign.</p>
<h3 id="web-of-trust"><a class="header" href="#web-of-trust">Web of trust</a></h3>
<p>The <a href="https://en.wikipedia.org/wiki/Web_of_trust">web of trust</a> is a special case of cross-signing, where any party can cross-sign the cryptographic identity of any other party and publish its cross-signature in a publicly accessible directory. A party judging the trustworthiness of a cryptographic identity can base its decision on the quantity and quality of cross-signatures for a given identity, where the quality of the signature is equivalent to the amount of trust placed in the cross-signer.</p>
<p>While other verification approaches have a clear condition under which the receiver will trust the veracity of a sender’s cryptographic identity, this is not necessarily the case with the web of trust. Here, the receiver has to decide to which degree it trusts a certain cryptographic identity depending on who signed a sender’s identity and how much the receiver trust the signers.</p>
<ul>
<li>The web of trust is used in PGP, where parties can upload their signature over other cryptographic identities to a well-known set of public key servers. The receiver can download the sender’s public key and check who has cross-signed it. If the receiver concludes that enough people have signed whom it trusts (and the public keys of whom it has already verified), the receiver can use the sender’s public key for authentication.</li>
</ul>
<p><strong>Threat model:</strong> The verifier has several parties that it trusts to verify other cryptographic identities for them and the identity of which the verifier has indeed verified. The adversary cannot compromise enough trusted parties to pass the threshold required for the verifier to trust that a cryptographic identity is valid.</p>
<h2 id="verifiable-data-structures"><a class="header" href="#verifiable-data-structures">Verifiable data structures</a></h2>
<p><a href="https://transparency.dev/verifiable-data-structures/">Verifiable data structures</a> cannot prevent MITM attacks entirely, but make them harder for an adversary to perform without detection.</p>
<p>A TTP (or any other party that either publishes cryptographic identities or provides delegated verification) can record its actions (either publication or verification of a cryptographic identity) in a verifiable data structure. The data structure allows the TTP to prove to other parties that its records are consistent (i.e. that past records were not altered or deleted) and that individual entries are indeed part of the data structure (proof of inclusion of a given record). The TTP can then regularly publish a <em>view</em> of its current records in which an inclusion proof holds. Consistency is then guaranteed by providing proofs that a view is the successor of previous view.</p>
<p>Parties can now check that their own identity is correct in the view that the TTP presents to them.</p>
<p>Also two communicating parties can include the view they received from the TTP in their messages. If two views differ (and one is not a successor of the other), it is a sign that the TTP has tampered with its records and shown different records to the two parties.</p>
<ul>
<li>Certificate authorities (CAs) in the WebPKI can (and are sometimes required to) use Certificate Transparency to publish the server certificates they sign. Clients can demand from servers to prove that its certificate has been published in the Certificate Transparency log. If a (CA-signed) certificate is used to conduct a MITM attack, there is proof that the CA has either accidentally or intentionally helped facilitate the attack.</li>
</ul>
<p><strong>Threat model:</strong> The adversary can compromise the TTP and actively impersonate a party towards a victim by claiming that one of their own identities is the genuine identity of the victim. However, it will have to show different views to the impersonated party and the victim. If parties exchange their views of the TTP with one-another, the adversary has to decide which party to show which view to avoid detection. If two parties exchange differing views, the adversary is caught.</p>
<h2 id="verification-question"><a class="header" href="#verification-question">Verification question</a></h2>
<p>Similar to an OOB channel, the sender and receiver can use shared information to help gain trust in one another’s cryptographic identity. <a href="https://dl.acm.org/doi/abs/10.1145/1314333.1314340">An adaptation of the socialist millionaire problem</a> allows one party to ask a question and provide the expected answer. The other party learns the question and provides its answer. The protocol then allows the parties to learn both if their replies and their shared cryptographic identities match without leaking their specific answers.</p>
<ul>
<li>The Off-the-Record (OTR) protocol allows for authentication via a verification question as described above to verify cryptographic identities. The initiating user is asked to provide a question and corresponding answer. The responder is then shown the question and also prompted for an answer. If the answers match, the identities are considered verified.</li>
</ul>
<p><strong>Threat model:</strong> The adversary can control the network completely, as long as it doesn’t know the answer to the question.</p>
<h1 id="approaches-used-in-messaging-applications"><a class="header" href="#approaches-used-in-messaging-applications">Approaches used in messaging applications</a></h1>
<p>Different messaging applications make use of one or more of the authentication approaches, sometimes with small variations to the general concepts described above.</p>
<h3 id="multi-client-or-composed-user-identities"><a class="header" href="#multi-client-or-composed-user-identities">Multi-client or composed user identities</a></h3>
<p>Messaging applications often allow the use of multiple clients (e.g. on different devices) by a single user. However, since users are typically interested in authenticating users rather than individual clients, applications have to deal with the challenge of presenting a single user identity despite messages being sent potentially from more than one client.</p>
<p>Multi-client authentication is not covered in the discussion of existing approaches above, because the individual messaging applications have found unique ways of dealing with this problem.</p>
<h2 id="signal"><a class="header" href="#signal">Signal</a></h2>
<p>The Signal app takes the TTP approach to authentication with <a href="https://support.signal.org/hc/en-us/articles/360007060632-What-is-a-safety-number-and-why-do-I-see-that-it-changed-">optional OOB verification by the user</a>. Users can discover other users via the Signal servers. Once a connection is established with another user, the server provides both users with the cryptographic identities of their peers. The same is true if a user joins a group with other users with whom it doesn’t necessarily have a previous connection.</p>
<p>Additionally, users can verify the identity of other users out-of-band, either by comparing a numerical code or by scanning a QR code. Notably, the code presented by the Signal app is not the cryptographic identity of a specific user, but instead a byte string specific to the connection between the users.</p>
<h3 id="multi-client"><a class="header" href="#multi-client">Multi-client</a></h3>
<p>Signal provisions all clients of a user with the same cryptographic identity, thus allowing users to perform OOB verification a single time to verify the cryptographic identity of all of the clients of a given user.</p>
<p>Since all clients have the same identity and thus can’t be told apart cryptographically, there is no way to revoke the individual cryptographic identity of a client. However, client removal is still possible with the assistance of the Signal server, which manages the message queues of individual clients.</p>
<h2 id="whatsapp"><a class="header" href="#whatsapp">WhatsApp</a></h2>
<p>WhatsApp uses the same general approach to authentication as Signal. Cryptographic identities are distributed via the WhatsApp servers, which act as TTPs. Users can additionally verify the safety numbers OOB, with the app providing the ability to scan another user’s safety number via a QR code. However, safety numbers are computed differently than by the Signal app, which is due to WhatsApp’s different approach to multi-client.</p>
<h3 id="multi-client-1"><a class="header" href="#multi-client-1">Multi-client</a></h3>
<p>Even though both applications share the underlying protocol, WhatsApp takes a different approach to multiple clients than Signal. Instead of sharing a cryptographic identity, each client has its own, distinct identity. Consequently, the <a href="https://faq.whatsapp.com/791574747982248/?locale=en_US">safety number</a> for a pair of users is computed from the set of clients of both users. Thus, when comparing safety numbers OOB, users also verify their view of each other’s clients.</p>
<p>If a client is added, WhatsApp takes a <a href="https://engineering.fb.com/2021/07/14/security/whatsapp-multi-device/">cross-signing approach</a> in addition to the TTP approach with optional OOB verification. When adding a new client, an existing client is required to sign the cryptographic identity of the new one. This does not happen automatically but instead requires the user to scan the identity of the new client using the existing one. The signed identity of the new client is then sent to the peers of the user. The user’s peers can thus trust the new client as much as it trusted the existing client. In particular, if user and peer previously verified safety codes OOB, they do not have to do so again after the addition of the new client.</p>
<p>Similarly, the user can revoke its own clients with an existing client authenticating the revocation.</p>
<h2 id="keybase"><a class="header" href="#keybase">Keybase</a></h2>
<p>Keybase keeps a <a href="https://book.keybase.io/docs/teams/sigchain">signature chain</a> as the user’s cryptographic identity. That signature chain contains the identities of all of the users’ clients and can, optionally, include other “proofs of identity”, such as a link to a social media account. This link is verified by the Keybase servers rather than by other end users. The chain can only be extended by the user’s clients. The chain is never shortened and clients are removed by recording the removal in the chain rather than shortening or changing the chain.</p>
<p>Since the chain is distributed by the Keybase servers, the approach is a TTP approach with optional OOB verification and added links to external (non-cryptographic) identities.</p>
<h3 id="multi-client-2"><a class="header" href="#multi-client-2">Multi-client</a></h3>
<p>Each client has its own cryptographic identity. A new client is added to the chain by an existing client upon creation. Similarly, client removals are recorded on the chain by the client performing the removal.</p>
<h2 id="threema"><a class="header" href="#threema">Threema</a></h2>
<p>Threema follows a TTP approach with optional OOB verification (see page 6 on <a href="https://threema.ch/press-files/2_documentation/cryptography_whitepaper.pdf">Threema’s cryptography whitepaper</a>). Threema is special in that it very prominently displays the degree of authentication for a given contact. If the cryptographic identity of a given contact was simply fetched from the Threema server, it shows a single red point. If there is a phone number or email address associated with the contact that is already in the user’s address book, it shows two orange points (this is essentially still relying entirely on the TTP). Finally, if the user has performed an OOB verification, it shows three green points.</p>
<h3 id="multi-client-3"><a class="header" href="#multi-client-3">Multi-client</a></h3>
<p>The multi-client approach taken by Threema is not reflected in the user’s cryptographic identity (see page 20 and following in the whitepaper linked above). There is a primary (mobile) client, with the option to open a secondary client in a browser. That client does not have its own cryptographic identity but instead relays messages through the primary client.</p>
<p>The secondary clients can be managed by the primary client.</p>
<h2 id="pgp"><a class="header" href="#pgp">PGP</a></h2>
<p>PGP follows the web of trust approach with optional OOB verification. As described above, users can use their cryptographic identities to sign those of other users. This usually happens after the user has verified OOB that a given identity indeed belongs to the user in question. A user who has no way to verify an identity OOB can then check the existing signatures on the identity and decide, depending on how much the user trusts the judgment of the signers if the it can trust the identity in question.</p>
<h3 id="multi-client-4"><a class="header" href="#multi-client-4">Multi-client</a></h3>
<p>PGP doesn’t have a notion of clients specifically and instead requires the user to manage its own key material. It is thus possible to either use different identities on different clients or just use the same on all clients. The user is also free to choose if and how to cross-sign the identities or to use a hierarchy of identities.</p>
<h2 id="element"><a class="header" href="#element">Element</a></h2>
<p>Element clients obtain the identity of their peers from their respective home servers, which act as trusted third parties. In addition, Element allows the verification of users OOB either in an interactive process, where users compare a sequence of Emoji in real-time or by comparing the full “session key” (which is presumably the client’s Curve25519 identity key). The former approach has to happen in real-time, which allows Element to only display a short sequence of emoji, while the latter can happen asynchronously.</p>
<h3 id="multi-client-5"><a class="header" href="#multi-client-5">Multi-client</a></h3>
<p>Element clients have distinct identity keys. When a new client is created, it <a href="https://element.io/enterprise/device-verification">can be cross-signed</a> by an existing client. Thus, when performing the OOB verification process described above, all cross-signed clients are verified at once. Interestingly, after an OOB verification took place, new clients have to be verified even after they were cross-signed by an existing client. See also the Matrix specification for <a href="https://spec.matrix.org/v1.3/client-server-api/#cross-signing">cross-signing</a>.</p>
<p>Peers keep track of a user’s clients (<em>devices</em> in the Matrix specification) by periodically checking the user’s list of devices. If a user changes its list of devices, e.g. by removing a device, its peers will learn of this when they next synchronize with their respective homeservers.</p>
<h2 id="imessage"><a class="header" href="#imessage">iMessage</a></h2>
<p>iMessage <a href="https://support.apple.com/guide/security/how-imessage-sends-and-receives-messages-sec70e68c949/web">purely relies on the TTP approach</a>, where Apple distributes the cryptographic identities of individual parties to conversation partners. There is no way for parties to verify their peers’ public keys OOB.</p>
<h3 id="multi-client-6"><a class="header" href="#multi-client-6">Multi-client</a></h3>
<p>iMessage clients have their own cryptographic identity and Apple automatically distributes keys of new clients, as well as changes to a user’s client list to a user’s contacts.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>

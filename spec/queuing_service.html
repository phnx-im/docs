<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Queuing service - Docs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="../functional_requirements.html"><strong aria-hidden="true">1.</strong> Functional Requirements</a></li><li class="chapter-item expanded "><a href="../modularization.html"><strong aria-hidden="true">2.</strong> Modularization</a></li><li class="chapter-item expanded "><a href="../performance_goals.html"><strong aria-hidden="true">3.</strong> Performance Goals</a></li><li class="chapter-item expanded "><a href="../threat_model.html"><strong aria-hidden="true">4.</strong> Threat Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../threat_model/methodology.html"><strong aria-hidden="true">4.1.</strong> Methodology</a></li><li class="chapter-item expanded "><a href="../threat_model/security_assumptions.html"><strong aria-hidden="true">4.2.</strong> Security Assumptions</a></li><li class="chapter-item expanded "><a href="../threat_model/application_assets.html"><strong aria-hidden="true">4.3.</strong> Application Assets</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements.html"><strong aria-hidden="true">4.4.</strong> Security Requirements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../threat_model/security_requirements/operators.html"><strong aria-hidden="true">4.4.1.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/public.html"><strong aria-hidden="true">4.4.2.</strong> Public</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/users.html"><strong aria-hidden="true">4.4.3.</strong> Users</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/clients.html"><strong aria-hidden="true">4.4.4.</strong> Clients</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/federated_homeservers.html"><strong aria-hidden="true">4.4.5.</strong> Federated Homeservers</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/federated_users.html"><strong aria-hidden="true">4.4.6.</strong> Federated Users</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/federated_clients.html"><strong aria-hidden="true">4.4.7.</strong> Federated Clients</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../cryptographic_primitives.html"><strong aria-hidden="true">5.</strong> Cryptographic Primitives and Schemes</a></li><li class="chapter-item expanded "><a href="../spec.html"><strong aria-hidden="true">6.</strong> Specification (Draft)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/authentication_service.html"><strong aria-hidden="true">6.1.</strong> Authentication service</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/authentication_service/credentials.html"><strong aria-hidden="true">6.1.1.</strong> Credentials</a></li><li class="chapter-item expanded "><a href="../spec/authentication_service/evolving_identities.html"><strong aria-hidden="true">6.1.2.</strong> Evolving Identities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/authentication_service/new_device_flow.html"><strong aria-hidden="true">6.1.2.1.</strong> Adding new devices</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/authentication_service/connection_establishment.html"><strong aria-hidden="true">6.1.3.</strong> Discovery and connection esablishment</a></li><li class="chapter-item expanded "><a href="../spec/authentication_service/security_guarantees.html"><strong aria-hidden="true">6.1.4.</strong> Security Guarantees</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/delivery_service.html"><strong aria-hidden="true">6.2.</strong> Delivery service</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/delivery_service/group_state_encryption.html"><strong aria-hidden="true">6.2.1.</strong> Group state encryption</a></li><li class="chapter-item expanded "><a href="../spec/delivery_service/broken_state_detection.html"><strong aria-hidden="true">6.2.2.</strong> Broken state detection</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/queuing_service.html" class="active"><strong aria-hidden="true">6.3.</strong> Queuing service</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/queuing_service/queue_encryption.html"><strong aria-hidden="true">6.3.1.</strong> Queue encryption</a></li><li class="chapter-item expanded "><a href="../spec/queuing_service/keypackage_publication.html"><strong aria-hidden="true">6.3.2.</strong> KeyPackage publication</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/federation.html"><strong aria-hidden="true">6.4.</strong> Federation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/federation/use_cases_and_threat_model.html"><strong aria-hidden="true">6.4.1.</strong> Use-cases and Threat Model</a></li><li class="chapter-item expanded "><a href="../spec/federation/federation_protocol.html"><strong aria-hidden="true">6.4.2.</strong> Federation protocol</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/clients.html"><strong aria-hidden="true">6.5.</strong> Work in progress: Clients</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/clients/client_sync.html"><strong aria-hidden="true">6.5.1.</strong> Client synchronization</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/future_work.html"><strong aria-hidden="true">6.6.</strong> Future work</a></li><li class="chapter-item expanded "><a href="../spec/glossary.html"><strong aria-hidden="true">6.7.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><a href="../authentication_systems.html"><strong aria-hidden="true">7.</strong> Authentication in messaging applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../authentication_systems/concepts.html"><strong aria-hidden="true">7.1.</strong> Concepts and security properties</a></li><li class="chapter-item expanded "><a href="../authentication_systems/comparison.html"><strong aria-hidden="true">7.2.</strong> Comparison of existing applications</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Docs</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="queuing-service-qs"><a class="header" href="#queuing-service-qs">Queuing Service (QS)</a></h1>
<p>The main purpose of the queuing service is to store-and-forward messages delivered by the <a href="./delivery_service.html">delivery service</a>, as well as the publication of KeyPackages. In this chapter we discuss the various concepts used by the QS to provide its functionalitites, as well as its individual endpoints.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The store-and-forwards functionality of the QS is designed in such a way that the QS cannot link the state it maintains for each of the homeserver's users with the user's actual identity as maintained by the AS.</p>
<p>To avoid a connection with the user's actual identity, each user has a QS user record with a sub-record for each of the user's clients. The records are created by the user's clients when they register with the AS.</p>
<p>After creation, the user's clients can publish KeyPackages and fetch messages from their queue, as well as rotate the key material used for authentication, or for at-rest encryption of queued messages.</p>
<p>The QS user record also contains the user's <a href="glossary.html#friendship-token">friendship token</a>, which the QS uses to authenticate requests for batches of the user's KeyPackages.</p>
<p>The client-specific records contain the client's fan-out queue (for messages received from a local or a federated DS), as well as the KeyPackages published by the client. See <a href="queuing_service/keypackage_publication.html">here</a> for more information on KeyPackage publication and how unlinkability between a user's real identity and its pseudonym is maintained.</p>
<p>The fan-out queue in turn contains an optional push-token (encrypted at-rest under the owning client's <a href="glossary.html#push">push-token encryption key</a>), as well as key material used for the <a href="queuing_service/queue_encryption.html">queue's at-rest encryption</a>.</p>
<h2 id="qs-state"><a class="header" href="#qs-state">QS state</a></h2>
<p>The QS keeps the following state.</p>
<ul>
<li><strong>QS user records:</strong> Indexed by a <a href="glossary.html#qs-user-id-qsuid">QsUid</a>, each record contains a number of sub fields.
<ul>
<li><strong>QS user record auth key:</strong> <a href="glossary.html#qs-user-record-auth-key">Public signature key</a> used by a user to authenticate itself as the owner of this record.</li>
<li><strong>Friendship token:</strong> Clients have to provide the friendship token to obtain a bundle of KeyPackages for a given user.</li>
<li><strong>Client specific records:</strong> For each of the user's clients, the QS keeps the following state. Indexed by a <a href="glossary.html#qs-client-id-qscid">QsCid</a>.
<ul>
<li><strong>Activity time:</strong> Timestamp indicating the last time a client has fetched messages from the queue.</li>
<li><strong>KeyPackages:</strong> Encrypted KeyPackages, each with an encrypted <a href="./glossary.html#client-credential-chain">client credential chain</a> attached. At least one KeyPackage has to be marked as KeyPackage of last resort.</li>
<li><strong>Public QS client record key:</strong> <a href="glossary.html#qs-client-record-auth-key">Public signature key</a>. Authenticates the owner of this QS client record and authorizes them to dequeue (i.e. fetch and delete) messages in the queue, as well as to change the queue configuration such as the authentication keys, or to add entries to the block list. Also authorizes the client to upload KeyPackages.</li>
<li><strong>Optional push token:</strong> The client's (optional) push token, stored encrypted at rest under the client's push token encryption key. Used by the QS to create a push notification for the client if a message is enqueued that includes the required encryption key.</li>
<li><strong>Fan-out queue:</strong> A fan-out queue with a number of further record fields attached.
<ul>
<li><strong>Queue encryption key material:</strong> Key material to perform <a href="./queuing_service/queue_encryption.html">queue encryption</a>.
<ul>
<li><strong>Queue encryption key:</strong> <a href="glossary.html#queue-encryption-key">HPKE public key</a> of the queue owner.</li>
<li><strong>Encryption ratchet key:</strong> Symmetric key used to derive queue encryption keys.</li>
</ul>
</li>
<li><strong>Current sequence number:</strong> The current message sequence number.</li>
<li><strong>Queued messages:</strong> A sequence of ciphertexts containing the messages in the queue. Each incoming message is <a href="./queuing_service/queue_encryption.html">encrypted</a> and is assigned the current sequence number, after which the current sequence number is incremented..</li>
<li><strong>Blocklist salt:</strong> Salt that is used when hashing values for the <em>Group blocklist</em>. Generated randomly by the QS upon queue creation.</li>
<li><strong>Blocklist:</strong> List of salted group ID hashes that the QS should not accept messages from for this queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Queue ID authentication key:</strong> A symmetric key that the QS uses to MAC a queue ID. Clients have to include that MAC when they encrypt their queue ID under the Queue ID encryption key. The QS uses this key to validate queue IDs after encryption and before enqueuing a message.</li>
<li><strong>Queue ID encryption keypair:</strong> <a href="glossary.html#queueconfig-encryption-key">A public/private HPKE keypair</a> that clients can encrypt their queue ID and queue id MAC under before providing it to a local or federated DS.</li>
<li><strong>QS signing key:</strong> <a href="./glossary.html#qs-signing-key">A public/private signature keypair</a> that the QS uses to sign KeyPackage bundles before returning them upon request. Also used to sign messages when forwarding them from the local DS to a remote QS.</li>
<li><strong>QS-to-QS queues:</strong> A database of queues indexed by the remote QS' domain. Each queue has the same queue encryption key material attached as the client queues.</li>
</ul>
<h2 id="qs-configuration-options"><a class="header" href="#qs-configuration-options">QS configuration options</a></h2>
<ul>
<li>Maximal InterQsAuthToken age: Maximal age of an <a href="./queuing_service.html#inter-qs-authentication">InterQsAuthToken</a> presented to the QS for inter-QS authentication.
<ul>
<li>Default: 1h</li>
</ul>
</li>
<li>Maximal QS client record age: Maximal age of an inactive QS client record.
<ul>
<li>Default: 90d</li>
</ul>
</li>
<li>Maximal number of requested messages: Maximal number of messages that will be returned to a client requesting messages from a queue.
<ul>
<li>Default: 500</li>
</ul>
</li>
<li>Ratchet key rotation interval: Interval in which queue encryption ratchet keys are rotated. See <a href="queuing_service/queue_encryption.html">here</a> for more details on queue encryption.</li>
<li>Maximal number of QS client records per user
<ul>
<li>Default: 10</li>
</ul>
</li>
</ul>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>Messages from the client to the QS are authenticated by the client by providing an QSAuthToken, where the QsSenderId in the token depends on the endpoint the client is querying.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum QsSenderId {
  QsUid(QsUid),
  QsCid(QsCid),
}

struct QsAuthToken {
  sender_id: QsSenderId,
  timestamp: Timestamp,
  // TBS: sender_id and timestamp
  signature: Signature,
}
<span class="boring">}</span></code></pre></pre>
<p>The verification key used to create the token depends on the sender_id:</p>
<ul>
<li>QsUid: <a href="./glossary.html#qs-user-record-auth-key">QS user record auth key</a></li>
<li>QsCid: <a href="./glossary.html#qs-client-record-auth-key">QS QS client record auth key</a></li>
</ul>
<h2 id="ds-to-qs-communication"><a class="header" href="#ds-to-qs-communication">DS-to-QS communication</a></h2>
<h3 id="enqueuing-messages"><a class="header" href="#enqueuing-messages">Enqueuing messages</a></h3>
<p>A local DS can enqueue the message sending just a <a href="./glossary.html#fan-out-message"><code>FanOutMessage</code></a>.</p>
<p>The receiving QS first checks the FQDNs in the <code>client_queue_configs</code> and
<a href="./queuing_service.html#federated-qs-to-qs-communication">forwards the messages for remote
QS'</a>.</p>
<p>For all local <code>client_queue_configs</code>, the QS decrypts the ciphertext, verifies the MACs using its symmetric
authentication key and checks if the QS client record exists. If it doesn't, it
responds to the sending QS with the following message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QueueDeleted {
  client_queue_config: ClientQueueConfig,
  group_id: GroupId,
}
<span class="boring">}</span></code></pre></pre>
<p>If the QS client record exists, the QS checks if the group ID in the
message is in the blocklist of the associated queue. If it isn't, the QS
enqueues the message.</p>
<h2 id="publicly-avaliable-endpoints"><a class="header" href="#publicly-avaliable-endpoints">Publicly avaliable endpoints</a></h2>
<h3 id="fetch-qs-verifying-key"><a class="header" href="#fetch-qs-verifying-key">Fetch QS verifying key</a></h3>
<p>A DS or QS can fetch the <a href="./glossary.html#qs-signing-key">QS' verifying key</a>
through this endpoint. This endpoint has to be reachable via a TLS connection to
allow the sender to authenticate the verifying key using its local web root of
trust.</p>
<h3 id="federated-qs-to-qs-communication"><a class="header" href="#federated-qs-to-qs-communication">Federated QS-to-QS communication</a></h3>
<p>This endpoint allows a remote QS to enqueue a <a href="glossary.html#fan-out-message">fan-out
message</a>. This endpoint has to be reachable via a
TLS connection only to allow the remote QS to authenticate this QS based on its
local web root of trust.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QsToQsMessage {
  source: Fqdn,
  destination: Fqdn,
  payload: FanOutMessage,
  signature: Signature,
}
<span class="boring">}</span></code></pre></pre>
<p>When receing a <code>QsToQsMessage</code>, the QS verifies that it is the intended
destination and tries to fetch the verifying key of the sending QS (if it is not
cached locally) based on the <code>source</code> field. The recipient QS then uses the
verifying key to verify the signature. If the signature is valid, the QS
processes the message like a message from its local QS.</p>
<h4 id="rate-limiting"><a class="header" href="#rate-limiting">Rate-limiting</a></h4>
<p>The QS can rate-limit messages from a federated QS in multiple ways. The most
obvious way is to rate-limit messages simply based on the sender's domain.
Secondly, the receiving QS can rate-limit based on the client queue config in
the FanOutMessage, which is unique to the group in the context of which the
message was fanned out. Finally, the QS can rate-limit the message based on the
decrypted queue config, i.e. on a per-queue/client basis.</p>
<h2 id="client-endpoints"><a class="header" href="#client-endpoints">Client endpoints</a></h2>
<p>Endpoints accessible to clients of the homeserver via HTTP requests.</p>
<h3 id="fetch-queue-config-encryption-key"><a class="header" href="#fetch-queue-config-encryption-key">Fetch queue config encryption key</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_QC_ENCRYPTION_KEY</code></li>
</ul>
<p>Clients can fetch the QS' <a href="./glossary.html#queueconfig-encryption-key">queue config encryption key</a> through this endpoint.</p>
<h3 id="user-record-management-endpoints"><a class="header" href="#user-record-management-endpoints">User record management endpoints</a></h3>
<p>Endpoints for management of QS user records. Note that a QS user record is deleted with its last QS client record.</p>
<h4 id="create-new-qs-user-record"><a class="header" href="#create-new-qs-user-record">Create new QS user record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_CREATE_USER_RECORD</code></li>
</ul>
<p>Create a new QS user record, as well as a first QS client record.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateUserRecordParams {
  user_record_auth_key: SignaturePublicKey,
  friendship_token: FriendshipToken,
  client_record_auth_key: SignaturePublicKey,
  queue_encryption_key: HpkePublicKey,
}
<span class="boring">}</span></code></pre></pre>
<p>The QS creates the QS user record and QS client record, indexed by a freshly sampled QsUid and QsCid. The QS returns the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateUserRecordResponse {
  qs_uid: QsUid,
  qs_cid: QsCid,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="update-qs-user-record"><a class="header" href="#update-qs-user-record">Update QS user record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_UPDATE_USER_RECORD</code></li>
</ul>
<p>Update a given QS user record, overwriting the existing values with the one given in the message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UpdateUserRecordParams {
  qs_uid: QsUid,
  user_record_auth_key: SignaturePublicKey,
  friendship_token: FriendshipToken,
}
<span class="boring">}</span></code></pre></pre>
<h5 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h4 id="get-own-qs-user-record"><a class="header" href="#get-own-qs-user-record">Get own QS user record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_USER_RECORD</code></li>
</ul>
<p>Get the data associated with a given QS user record that you own.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserRecordParams {
  qs_uid: QsUid,
}
<span class="boring">}</span></code></pre></pre>
<p>The QS returns the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UserRecordResponse {
  user_record_auth_key: SignaturePublicKey,
  friendship_token: FriendshipToken,
  client_records: Vec&lt;ClientRecordResponse&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h5 id="authentication-2"><a class="header" href="#authentication-2">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h4 id="delete-qs-user-record"><a class="header" href="#delete-qs-user-record">Delete QS user record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_DELETE_USER_RECORD</code></li>
</ul>
<p>Delete the given QS user record including all associated QS client records.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DeleteUserRecordParams {
  qs_uid: QsUid,
}
<span class="boring">}</span></code></pre></pre>
<h5 id="authentication-3"><a class="header" href="#authentication-3">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h5 id="future-work-mfa-for-user-or-qs-client-record-deletion"><a class="header" href="#future-work-mfa-for-user-or-qs-client-record-deletion">Future work: MFA for user or QS client record deletion</a></h5>
<p>User and client deletion are very destructive operations. We should probably require MFA for the associated operations.</p>
<h3 id="client-record-management"><a class="header" href="#client-record-management">Client record management</a></h3>
<h4 id="create-new-qs-client-record"><a class="header" href="#create-new-qs-client-record">Create new QS client record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_CREATE_CLIENT_RECORD</code></li>
</ul>
<p>Create a new QS client record with the given data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateClientRecordParams {
  client_record_auth_key: SignaturePublicKey,
  queue_encryption_key: HpkePublicKey,
}
<span class="boring">}</span></code></pre></pre>
<p>The QS creates the record indexed by a freshly sampled QsCid and returns the following.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateClientRecordResponse {
  qs_cid: QsCid,
}
<span class="boring">}</span></code></pre></pre>
<h5 id="authentication-4"><a class="header" href="#authentication-4">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h4 id="update-qs-client-record"><a class="header" href="#update-qs-client-record">Update QS client record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_UPDATE_CLIENT_RECORD</code></li>
</ul>
<p>Update the data of the QS client record with the given QsCid with the given data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UpdateClientRecordParams {
  qs_cid: QsCid,
  client_record_auth_key: SignaturePublicKey,
  queue_encryption_key: HpkePublicKey,
  blocklist_entries: Vec&lt;GroupId&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h5 id="authentication-5"><a class="header" href="#authentication-5">Authentication</a></h5>
<ul>
<li>QsSenderId: QsCid</li>
</ul>
<h4 id="get-qs-client-record"><a class="header" href="#get-qs-client-record">Get QS client record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_CLIENT_RECORD</code></li>
</ul>
<p>Get the data associated with the QS client record with the given QsCid.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientRecordParams {
  qs_cid: QsCid,
}
<span class="boring">}</span></code></pre></pre>
<p>The QS returns the following data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientRecordResponse {
  client_record_auth_key: SignaturePublicKey,
  queue_encryption_key: HpkePublicKey,
  blocklist_entries: Vec&lt;GroupId&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h5 id="authentication-6"><a class="header" href="#authentication-6">Authentication</a></h5>
<ul>
<li>QsSenderId: QsCid</li>
</ul>
<h4 id="delete-qs-client-record"><a class="header" href="#delete-qs-client-record">Delete QS client record</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_DELETE_CLIENT_RECORD</code></li>
</ul>
<p>Delete the QS client record with the given QsCid if it is not the user's last QS client record. The last client in a QS user record can only be deleted by deleting the QS user record itself.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DeleteClientRecordParams {
  qs_cid: QsCid,
}
<span class="boring">}</span></code></pre></pre>
<h5 id="authentication-7"><a class="header" href="#authentication-7">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h4 id="publish-keypackages"><a class="header" href="#publish-keypackages">Publish KeyPackages</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_PUBLISH_KEY_PACKAGES</code></li>
</ul>
<p>Publish the given <a href="glossary.html#addpackage">AddPackage</a> under the given QsCid.</p>
<p>All of the KeyPackages contained in the AddPackages have to contain a <a href="glossary.html#queueconfig-extension">QueueConfigExtension</a> and at least one of the AddPackage has to contain a KeyPackage marked as <a href="glossary.html#last-resort-extension">KeyPackage of last resort</a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PublishKeyPackagesParams {
  qs_cid: QsCid,
  add_packages: Vec&lt;AddPackage&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The QS deletes all existing KeyPackages before publishing the new ones.</p>
<h5 id="authentication-8"><a class="header" href="#authentication-8">Authentication</a></h5>
<ul>
<li>QsSenderId: QsCid</li>
</ul>
<h5 id="future-work-allow-more-granular-keypackage-rotation"><a class="header" href="#future-work-allow-more-granular-keypackage-rotation">Future work: Allow more granular KeyPackage rotation</a></h5>
<p>Throwing all KeyPackages away regardless of their remaining validity is a bit wasteful. A client should have more granular control over which KeyPackages it wants to remain on the QS.</p>
<h5 id="future-work-more-than-one-last-resort-keypackage"><a class="header" href="#future-work-more-than-one-last-resort-keypackage">Future work: More than one last-resort KeyPackage</a></h5>
<p>Using the same KeyPackage of last resort in multiple groups can allow a federated DS to track the user across these groups. This could be mitigated somewhat by having multiple KeyPackages of last resort that the QS can cycle through when there are no other KeyPackages left.</p>
<h4 id="get-client-keypackage"><a class="header" href="#get-client-keypackage">Get client KeyPackage</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_CLIENT_KEY_PACKAGE</code></li>
</ul>
<p>Get the KeyPackage of the client with the given QsCid. This allows clients of a user to fetch individual AddPackages for other clients of the same user. These individual AddPackages are required to add new clients to existing groups.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientKeyPackageParams {
  qs_cid: QsCid,
}
<span class="boring">}</span></code></pre></pre>
<p>The QS returns one of the client's AddPackages and deletes the AddPackage afterwards (except if it contains a KeyPackage of last resort.)</p>
<h5 id="authentication-9"><a class="header" href="#authentication-9">Authentication</a></h5>
<ul>
<li>QsSenderId: QsUid</li>
</ul>
<h4 id="get-keypackage-batch"><a class="header" href="#get-keypackage-batch">Get KeyPackage batch</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_KEY_PACKAGE_BATCH</code></li>
</ul>
<p>Get a <a href="glossary.html#user-keypackage-batch">KeyPackageBatch</a> of the user with the given friendship token.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct KeyPackageBatchParams {
  friendship_token: FriendshipToken,
}
<span class="boring">}</span></code></pre></pre>
<p>The QS checks if there is a QS user record with the given <a href="glossary.html#friendship-token">FriendshipToken</a> and returns a <a href="glossary.html#addpackage">AddPackage</a> of each of the matching user's clients, along with a signed <a href="glossary.html#user-keypackage-batch">KeyPackageBatch</a> that includes a current time stamp and the references of the returned KeyPackages.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct KeyPackageBatchResponse {
  add_packages: Vec&lt;AddPackage&gt;,
  key_package_batch: KeyPackageBatch,
}
<span class="boring">}</span></code></pre></pre>
<h5 id="authentication-10"><a class="header" href="#authentication-10">Authentication</a></h5>
<p>Instead of a QSAuthToken, the QS requires the client to provide a friendship token. If the token matches the one in the QS user record, the query is considered valid.</p>
<h4 id="dequeue-messages"><a class="header" href="#dequeue-messages">Dequeue messages</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_DEQUEUE_MESSAGES</code></li>
</ul>
<p>Dequeue messages from a queue, starting with the message with the given sequence number.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DequeueMessagesParams {
  qs_cid: QsCid,
  sequence_number_start: u64,
  max_message_number: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>The QS deletes messages older than the given sequence number and returns messages starting with the given sequence number. The maximum number of messages returned this way is the smallest of the following values.</p>
<ul>
<li>The number of messages remaining in the queue</li>
<li>The value of the <code>max_message_number</code> field in the request</li>
<li>The QS configured maximum number of returned messages</li>
</ul>
<h5 id="authentication-11"><a class="header" href="#authentication-11">Authentication</a></h5>
<ul>
<li>QsSenderId: QsCid</li>
</ul>
<h4 id="negotiate-websocket-connection"><a class="header" href="#negotiate-websocket-connection">Negotiate websocket connection</a></h4>
<ul>
<li>Endpoint: <code>ENDPOINT_QS_WS</code></li>
</ul>
<p>Allows a client to create a websocket connection with the QS. If such a websocket connection exists then whenever the QS would send a push notification, it instead signals the client via the websocket connection.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WsParams {
  qs_cid: QsCid,
}
<span class="boring">}</span></code></pre></pre>
<h5 id="authentication-12"><a class="header" href="#authentication-12">Authentication</a></h5>
<ul>
<li>QsSenderId: QsCid</li>
</ul>
<h2 id="local-homeserver-endpoints"><a class="header" href="#local-homeserver-endpoints">Local homeserver endpoints</a></h2>
<p>Endpoints that are accessible by other services of the local homeserver. There is no authentication on these endpoints, as we assume that the infrastructure running the services provides sufficient access control.</p>
<h3 id="local-enqueue-message"><a class="header" href="#local-enqueue-message">Local enqueue message</a></h3>
<p>Receive a <a href="glossary.html#fan-out-message">fan-out-message</a> to store-and-forward to local clients with the specified ClientQueueConfigs.</p>
<p>The QS checks the <code>client_homeserver_domain</code> in the <code>client_queue_config</code>. If it is the homeserver's own domain, the QS decrypts the ciphertext and checks if the group ID given in the message is in the queue's blocklist. If it isn't, it enqueues the message.</p>
<p>If the domain is not the homerserver's own domain, the QS calls the <a href="queuing_service.html#federated-enqueue-message">federated enqueue message</a> endpoint of the QS of the corresponding domain.</p>
<p>If the QS learns that a message couldn't be delivered due to a missing queue, either because a local lookup has failed, or due to a response from a federated QS, it reports the <code>client_queue_config</code> and the group ID back to the DS via a <a href="queuing_service.html#federated-enqueue-message">QueueDeleted</a> message.</p>
<h4 id="future-work-persist-and-ear-encrypt-federated-messages"><a class="header" href="#future-work-persist-and-ear-encrypt-federated-messages">Future work: Persist and EAR encrypt federated messages</a></h4>
<p>We can't expect federated homeservers to be online all the time. Instead of sending the messages immediately, they should be stored-and-forwarded via a queue and encrypted-at-rest in the same way as with client queues.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../spec/delivery_service/broken_state_detection.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../spec/queuing_service/queue_encryption.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../spec/delivery_service/broken_state_detection.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../spec/queuing_service/queue_encryption.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

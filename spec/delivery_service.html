<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Delivery service - Docs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../status.html">Status</a></li><li class="chapter-item expanded "><a href="../functional_requirements.html"><strong aria-hidden="true">1.</strong> Functional Requirements</a></li><li class="chapter-item expanded "><a href="../modularization.html"><strong aria-hidden="true">2.</strong> Modularization</a></li><li class="chapter-item expanded "><a href="../performance_goals.html"><strong aria-hidden="true">3.</strong> Performance Goals</a></li><li class="chapter-item expanded "><a href="../threat_model.html"><strong aria-hidden="true">4.</strong> Threat Model</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../threat_model/methodology.html"><strong aria-hidden="true">4.1.</strong> Methodology</a></li><li class="chapter-item expanded "><a href="../threat_model/security_assumptions.html"><strong aria-hidden="true">4.2.</strong> Security Assumptions</a></li><li class="chapter-item expanded "><a href="../threat_model/application_assets.html"><strong aria-hidden="true">4.3.</strong> Application Assets</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements.html"><strong aria-hidden="true">4.4.</strong> Security Requirements</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../threat_model/security_requirements/operators.html"><strong aria-hidden="true">4.4.1.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/public.html"><strong aria-hidden="true">4.4.2.</strong> Public</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/users.html"><strong aria-hidden="true">4.4.3.</strong> Users</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/clients.html"><strong aria-hidden="true">4.4.4.</strong> Clients</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/federated_homeservers.html"><strong aria-hidden="true">4.4.5.</strong> Federated Homeservers</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/federated_users.html"><strong aria-hidden="true">4.4.6.</strong> Federated Users</a></li><li class="chapter-item expanded "><a href="../threat_model/security_requirements/federated_clients.html"><strong aria-hidden="true">4.4.7.</strong> Federated Clients</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../cryptographic_primitives.html"><strong aria-hidden="true">5.</strong> Cryptographic Primitives and Schemes</a></li><li class="chapter-item expanded "><a href="../spec.html"><strong aria-hidden="true">6.</strong> Specification (Draft)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/authentication_service.html"><strong aria-hidden="true">6.1.</strong> Work in progress: Authentication service</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/authentication_service/credentials.html"><strong aria-hidden="true">6.1.1.</strong> Credentials</a></li><li class="chapter-item expanded "><a href="../spec/authentication_service/evolving_identities.html"><strong aria-hidden="true">6.1.2.</strong> Evolving Identities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/authentication_service/new_device_flow.html"><strong aria-hidden="true">6.1.2.1.</strong> Adding new devices</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/authentication_service/connection_establishment.html"><strong aria-hidden="true">6.1.3.</strong> Discovery and connection esablishment</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/delivery_service.html" class="active"><strong aria-hidden="true">6.2.</strong> Delivery service</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/delivery_service/group_state_encryption.html"><strong aria-hidden="true">6.2.1.</strong> Group state encryption</a></li><li class="chapter-item expanded "><a href="../spec/delivery_service/broken_state_detection.html"><strong aria-hidden="true">6.2.2.</strong> Broken state detection</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/queuing_service.html"><strong aria-hidden="true">6.3.</strong> Queuing service</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/queuing_service/queue_encryption.html"><strong aria-hidden="true">6.3.1.</strong> Queue encryption</a></li><li class="chapter-item expanded "><a href="../spec/queuing_service/keypackage_publication.html"><strong aria-hidden="true">6.3.2.</strong> KeyPackage publication</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/clients.html"><strong aria-hidden="true">6.4.</strong> Work in progress: Clients</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../spec/clients/client_sync.html"><strong aria-hidden="true">6.4.1.</strong> Client synchronization</a></li></ol></li><li class="chapter-item expanded "><a href="../spec/future_work.html"><strong aria-hidden="true">6.5.</strong> Future work</a></li><li class="chapter-item expanded "><a href="../spec/glossary.html"><strong aria-hidden="true">6.6.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><a href="../authentication_systems.html"><strong aria-hidden="true">7.</strong> Authentication in messaging applications</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../authentication_systems/concepts.html"><strong aria-hidden="true">7.1.</strong> Concepts and security properties</a></li><li class="chapter-item expanded "><a href="../authentication_systems/comparison.html"><strong aria-hidden="true">7.2.</strong> Comparison of existing applications</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Docs</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="delivery-service-ds"><a class="header" href="#delivery-service-ds">Delivery Service (DS)</a></h1>
<p>The delivery service keeps track of groups and (pseudonymous) group membership and delivers messages to group members.</p>
<h2 id="ds-configuration-options"><a class="header" href="#ds-configuration-options">DS configuration options</a></h2>
<ul>
<li>Maximal KeyPackageBatch age: Maximal difference between a KeyPackageBatch timestamp and the current time when a new user is added to a group.
<ul>
<li>Default: 1h</li>
</ul>
</li>
<li>Maximal DSAuthToken age: Maximal age of an <a href="delivery_service.html#authentication">DSAuthToken</a> presented to the DS for client authentication.
<ul>
<li>Default: 1h</li>
</ul>
</li>
<li>Maximal duration of client commit inactivity: Maximal duration between two commits of an individual client before the removal of the client is proposed by the DS.
<ul>
<li>Default: 90d</li>
</ul>
</li>
</ul>
<h2 id="ds-state"><a class="header" href="#ds-state">DS state</a></h2>
<p>The DS has a database of EAR encrypted group states indexed by their group ID.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GroupStateDbEntry {
  encrypted_group_state: Vec&lt;u8&gt;,
  timestamp: Timestamp,
  deleted_queues: Vec&lt;SealedQueueConfig&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The plaintext group state contains the following data:</p>
<ul>
<li><strong>Public ratchet tree:</strong> The public MLS ratchet trees of the group.</li>
<li><strong>MLS GroupInfo:</strong> The <a href="https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#name-adding-members-to-the-group">GroupInfo</a> of this group.</li>
<li><strong>User profile:</strong> For each user that has at least one client in the group, the DS keeps the following records.
<ul>
<li><strong>Clients:</strong> The leaf indices of each client belonging to the user.</li>
<li><strong>User auth key:</strong> Public signature key known to all clients of a given user.</li>
</ul>
</li>
<li><strong>Client profile:</strong> For each client in the group, the DS keeps the following records.
<ul>
<li><strong>Client index:</strong> The client's leaf index in the public group tree.</li>
<li><strong>Client credential chain (encrypted):</strong> The intermediate client credentials for each of the user's clients, as well as the client's client credential, encrypted using the group state encryption key.</li>
<li><strong>Client queue config:</strong> The <a href="glossary.html#sealed-queue-config">client queue config</a> of the client.</li>
<li><strong>Activity time:</strong> A timestamp indicating either the time the client was added, or the last time the client has sent a commit (whatever is more recent).</li>
<li><strong>Activity epoch:</strong> Epoch of the last time the client has sent a commit (see activity time).</li>
</ul>
</li>
<li><strong>Past group states:</strong> Whenever a new KeyPackage is added to the group, the DS files a copy of the current epoch's group state and keeps it until all group members added in a given, past epoch have updated, or until all KeyPackages added in the given epoch have expired. The copies include the following data:
<ul>
<li><strong>Public ratchet tree</strong></li>
<li><strong>Client credential chain (encrypted)</strong></li>
<li><strong>Joining clients:</strong> List of the KeyPackagerefs of all clients that are expected to pick up this group state.</li>
</ul>
</li>
<li><strong>Proposal store:</strong> List of proposals sent in this group in this epoch. Gets cleared upon every epoch change.</li>
</ul>
<h2 id="proposal-store"><a class="header" href="#proposal-store">Proposal store</a></h2>
<ul>
<li>Proposal store is emptied after each successful commit</li>
<li>Proposals are added to the store either through user self removals,</li>
<li>If the proposal store is non-empty, the next commit must be a client update that contains all proposals in the proposal store. The DS must reject all other operations containing commits.</li>
<li>For all requests containing non-update commits, or commits that do not contain all proposals in the store, the DS will return an error message indicating the the proposal store is non-empty.</li>
</ul>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>Messages from the client to the DS are authenticated by the client by providing a <code>DsAuthToken</code>, where the <code>DsSenderId</code> in the token depends on the endpoint the client is querying.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum DsSenderId {
  LeafIndex(u32),
  KeyPackageRef(KeyPackageRef),
  UserKeyHash(Vec&lt;u8&gt;),
}

struct DsAuthToken {
  group_id: GroupId,
  timestamp: Timestamp,
  sender_id: DsSenderId,
  // TBS: group_id, timestamp and sender_id
  signature: Signature,
}
<span class="boring">}</span></code></pre></pre>
<p>The verification key used to create the token depends on the <code>sender_id</code>:</p>
<ul>
<li>LeafIndex: Signature key in the leaf's credential</li>
<li>KeyPackageRef: Signature key of the credential in the KeyPackage with the given KeyPackageRef</li>
<li>UserKeyHash: Signature key in the user profile indicated by the UserProfileHash</li>
</ul>
<h2 id="groupinfo-updates"><a class="header" href="#groupinfo-updates">GroupInfo updates</a></h2>
<p>When sending a commit to change the group state, the sender has to enable the DS to update the MLSGroupInfo of the group. Since the DS either already has most of the required data and can extract the rest from the message, the sender only has to include its signature over the new GroupInfo.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GroupInfoUpdate {
  signature: Signature,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="message-delivery"><a class="header" href="#message-delivery">Message delivery</a></h2>
<p>The majority of endpoints of the DS allow clients to send MLS messages to groups.</p>
<h3 id="validation"><a class="header" href="#validation">Validation</a></h3>
<p>Whenever receiving an MLS message at any endpoint, the DS checks if a local group state with the message's GroupId exists. If it does, the DS locks the corresponding database entry to prevent concurrent access. The DS then takes the GroupStateEarKey that is part of every message delivery request and decrypts the group state. Finally, the DS performs the same validation steps a receiving MLS client would perform, as well as the endpoint-specific validation steps.</p>
<p>The MLS client checks also includes checking that the epoch numbers match. In the case of commits, this comparison along with the lock on the database entry ensure that any conflicts between commits for the same epoch are resolved.</p>
<p>If all validation steps pass, the DS performs the endpoint and message-specific changes to its local group state.</p>
<h3 id="message-distribution"><a class="header" href="#message-distribution">Message distribution</a></h3>
<p>To distribute MLS messages the DS sends messages on to the local QS to enqueue in a local client's queue or to forward to a federated QS. For the message format see <a href="glossary.html#fan-out-message">here</a>.</p>
<p>In cases where the QS responds with a message indicating that a target queue doesn't exist, the DS assumes that the queue was deleted and proposes the removal of the corresponding group member as specified <a href="delivery_service.html#ds-induced-removals">here</a>.</p>
<h2 id="activity-time"><a class="header" href="#activity-time">Activity time</a></h2>
<p>Whenever a client sends a commit as part of a query to an endpoint, the DS updates the <em>activity time</em> and <em>activity epoch</em> of the sender.</p>
<h2 id="client-endpoints"><a class="header" href="#client-endpoints">Client endpoints</a></h2>
<p>Endpoints meant to be accessed by clients registered with the homeserver via HTTP requests.</p>
<h3 id="request-group-id"><a class="header" href="#request-group-id">Request group id</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_GROUP_ID</code></li>
</ul>
<p>Request a fresh group id for use with the <a href="delivery_service.html#create-group">create group</a> endpoint. The DS samples a fresh group id, checks for collisions and, if none are found, enters the group id as a placeholder into the database. If a collision is found, the DS re-samples until there are no collisions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RequestGroupIdResponse {
  group_id: GroupId,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h4>
<ul>
<li>None</li>
</ul>
<h3 id="create-group"><a class="header" href="#create-group">Create group</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_CREATE_GROUP</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CreateGroupParams {
  group_id: GroupId,
  key_package: KeyPackage,
  encrypted_credential_chain: Vec&lt;u8&gt;,
  creator_queue_config: ClientQueueConfig,
  creator_user_auth_key: UserAuthKey,
  group_info: GroupInfo,
  initial_ear_key: GroupStateEarKey,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The DS checks if there is a placeholder in the group database for this group id. If there is, it creates the GroupStateDbEntry.</li>
</ul>
<h4 id="authentication-2"><a class="header" href="#authentication-2">Authentication</a></h4>
<ul>
<li>DsSenderId: UserKeyHash</li>
</ul>
<h4 id="future-work-obfuscate-group-creator"><a class="header" href="#future-work-obfuscate-group-creator">Future work: Obfuscate group creator</a></h4>
<ul>
<li>A leaf index of 0 can be a strong indicator that the client with that index is the original creator of the group.</li>
<li>It would be good to allow clients to start groups with them in another position than 0.</li>
</ul>
<h3 id="update-queue-information"><a class="header" href="#update-queue-information">Update queue information</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_UPDATE_QUEUE_INFO</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UpdateQueueInfoParams {
  group_id: GroupId,
  group_state_ear_key: GroupStateEarKey,
  new_queue_config: ClientQueueConfig,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="authentication-3"><a class="header" href="#authentication-3">Authentication</a></h4>
<ul>
<li>DsSenderId: LeafIndex</li>
</ul>
<h3 id="get-welcome-information"><a class="header" href="#get-welcome-information">Get Welcome information</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_WELCOME_INFO</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct WelcomeInfoParams {
  group_id: GroupId,
  group_state_ear_key: GroupStateEarKey,
  epoch: Epoch,
}

struct WelcomeInfoResponse {
  public_tree: MlsRatchetTree,
  credential_chains: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="authentication-4"><a class="header" href="#authentication-4">Authentication</a></h4>
<ul>
<li>DSSenderId: KeyPackageRef</li>
</ul>
<h3 id="get-external-commit-information"><a class="header" href="#get-external-commit-information">Get External Commit information</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_EXTERNAL_COMMIT_INFO</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ExternalCommitInfoParams {
  group_id: GroupId,
  group_state_ear_key: GroupStateEarKey,
}

struct WelcomeInfoResponse {
  group_info: GroupInfo,
  public_tree: MlsRatchetTree,
  credential_chains: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="authentication-5"><a class="header" href="#authentication-5">Authentication</a></h4>
<ul>
<li>DSSenderId: UserKeyHash</li>
</ul>
<h3 id="adding-new-users-to-the-group"><a class="header" href="#adding-new-users-to-the-group">Adding new users to the group</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_ADD_USERS</code></li>
</ul>
<p>Operation, where the commit contains one or more inline Add proposals containing clients of one or more new users. The sender has to additionally provide a signature of the user's QS to help the DS validate that the KeyPackages indeed all belong to one user, as well as a timestamp to prove that the KeyPackages were recently obtained.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AddUsersParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
  welcome: Welcome,
  welcome_attribution_info: Vec&lt;WelcomeAttributionInfo&gt;,
  key_package_batches: Vec&lt;KeyPackageBatch&gt;,
}

struct AddUsersParamsAad {
  encrypted_credential_information: Vec&lt;Vec&lt;u8&gt;&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>commit</code> must include the <code>AddUserParamsAad</code> of all added users in the AAD of the MLSContent, where the ciphertexts in the <code>encrypted_credential_information</code> are sorted in the same way as the Add proposals in the <code>commit</code>.</p>
<p>This operation can only be performed by clients of users marked as <em>admin</em> and all KeyPackages have to contain an extension that contains a <a href="./glossary.html#sealed-queue-config">ClientQueueConfig</a>.</p>
<p>Upon reception, the DS hashes the KeyPackages in all Add proposals contained in the commit. The KeyPackageBatches indicate, which KeyPackages belong to which user. If there are KeyPackages for which there is no matching KeyPackageRef in any KeyPackageBatch, or if there is a KeyPackageRef in a batch that has no corresponding Add proposal, the commit is invalid. Otherwise, the DS creates a user proile for each batch with the leaf indices of the KeyPackages referenced within. The user auth key of the new user remains empty until the first update of one of the user's clients.</p>
<p>The DS also has to verify that the timestamp is not older than the DS' configured maximal KeyPackageBatch age.</p>
<p>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue. It also sends <a href="./glossary.html#welcomebundle">WelcomeBundles</a> to the newly added clients.</p>
<h4 id="authentication-6"><a class="header" href="#authentication-6">Authentication</a></h4>
<ul>
<li>DsSenderId: UserKeyHash</li>
</ul>
<h4 id="future-work-tighten-up-ds-validation-using-zero-knowledge-proofs"><a class="header" href="#future-work-tighten-up-ds-validation-using-zero-knowledge-proofs">Future work: Tighten up DS validation using Zero-Knowledge proofs</a></h4>
<ul>
<li>ZKPs could allow the DS to verify that the sender of a Welcome sends the correct encrypted information</li>
<li>Alternatively, the recipient of the Welcome could let the DS know that it received a bogus Welcome. The problem here is how the recipient can prove that the Welcome is indeed bogus.</li>
</ul>
<h3 id="remove-users"><a class="header" href="#remove-users">Remove users</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_REMOVE_USERS</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RemoveUserParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The commit must exclusively contain Remove proposals</li>
<li>The commit must contain Remove proposals for all clients of all evicted users</li>
<li>The sending client must be a client of an admin</li>
<li>The DS validates the commit and updates its public tree</li>
<li>The DS removes the user profiles for the evicted users and the encrypted credential information of all of their clients</li>
<li>Note, that a user can't remove itself due to MLS constraints</li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-7"><a class="header" href="#authentication-7">Authentication</a></h4>
<ul>
<li>DsSenderId: UserKeyHash</li>
</ul>
<h3 id="updating-the-sending-clients-own-key-material"><a class="header" href="#updating-the-sending-clients-own-key-material">Updating the sending client's own key material</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_UPDATE_CLIENT</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UpdateClientParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
}

struct UpdateClientParamsAad {
    option_encrypted_credential_information: Option&lt;Vec&lt;u8&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>DS validates the commit and changes its public tree
<ul>
<li>The commit must contain an update path, as well as all pending proposals</li>
<li>If the credential in the sender's KeyPackage has changed, there must be encrypted credential information in the AAD</li>
</ul>
</li>
<li>If there is encrypted client credential information in the commit's AAD, the DS also updates its corresponding state</li>
<li>If a remove proposal is committed as part of the commit, the DS removes the associated client profile and updates the owning user's user profile. If the remove proposal removes the last client of a user, it also removes the associated user profile.</li>
<li>If the KeyPackageRef of the updating client (prior to applying the update) is in one of the <em>joining clients</em> vectors in the group's storage of old group states, the DS removes that KeyPackageRef from the vector. If this leaves te vector empty, the DS removes this particular copy of the group state.</li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-8"><a class="header" href="#authentication-8">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h4 id="future-work-base-user-secret-rotation"><a class="header" href="#future-work-base-user-secret-rotation">Future work: Base user secret rotation</a></h4>
<ul>
<li>Although the group secret should provide sufficient PCS guarantees after a client removal, users should also be able to rotate their base user secret.</li>
<li>This is tricky, because a rotation would affect all groups simultaneously.</li>
</ul>
<h3 id="join-group-with-new-client"><a class="header" href="#join-group-with-new-client">Join group with new client</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_JOIN_GROUP</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct JoinGroupParams {
  external_commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
}

struct JoinGroupParamsAad {
  existing_user_clients: Vec&lt;LeafIndex&gt;,
  encrypted_credential_information: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The DS verifies that the <code>existing_user_clients</code> correspond to the leaf indices in the user profile of the sending user (identified via the UserKeyHash used for authentication)</li>
<li>An adversary could make the state of clients and DS diverge if it has two users in a group and sends the commit with a client of one user while using the user auth key of the other. The existing_user_clients allows other group members to verify that the adder didn't falsely claim to be another user towards the DS. If the adder did indeed misbehave, other group members can rectify the error as described <a href="./delivery_service/broken_state_detection.html">here</a>.</li>
</ul>
<h4 id="authentication-9"><a class="header" href="#authentication-9">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h3 id="join-connection-group"><a class="header" href="#join-connection-group">Join connection group</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_JOIN_CONNECTION_GROUP</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct JoinConnectionGroupParams {
  external_commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
}

struct JoinConnectionGroupParamsAad {
  encrypted_credential_information: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The DS checks if the group contains only a single user. Every single-user group can be joined as a connection group.</li>
</ul>
<h4 id="authentication-10"><a class="header" href="#authentication-10">Authentication</a></h4>
<p>No additional authentication is required for this endpoint. The knowledge of the group's EAR key effectively authenticates the joining client.</p>
<h3 id="add-own-clients"><a class="header" href="#add-own-clients">Add own clients</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_ADD_CLIENTS</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct AddClientsParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
  welcome: Welcome,
  welcome_attribution_info: WelcomeAttributionInfo,
}

struct AddClientsParamsAad {
  encrypted_credential_information: Vec&lt;u8&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The commit must contain exclusively Add proposals</li>
<li>This endpoint brings the same potential to break the group state as the &quot;Join with new client&quot; endpoint. See there for more information.</li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
<li>It also sends <a href="./glossary.html#welcomebundle">WelcomeBundles</a> to the newly added clients.</li>
</ul>
<h4 id="authentication-11"><a class="header" href="#authentication-11">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h3 id="remove-own-clients"><a class="header" href="#remove-own-clients">Remove own clients</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_REMOVE_CLIENTS</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RemoveClientsParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
  user_auth_key: UserAuthKey,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The commit must exclusively contain Remove proposals</li>
<li>The DS validates the commit and updates its public tree</li>
<li>The DS removes the encrypted credential information of all of removed clients</li>
<li>Note, that a user can't remove itself due to MLS constraints</li>
<li>The DS replaces the user auth key of the sender's user profile with the <code>user_auth_key</code></li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-12"><a class="header" href="#authentication-12">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h3 id="resync"><a class="header" href="#resync">ReSync</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_RESYNC_CLIENT</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ResyncClientParams {
  external_commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
  group_info_update: GroupInfoUpdate,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The commit must contain exactly one Add and one Remove proposal referencing the same leaf</li>
<li>The DS validates the commit and updates its public tree</li>
<li>The leaf credential of the resynced client must remain the same</li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-13"><a class="header" href="#authentication-13">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h3 id="client-self-remove"><a class="header" href="#client-self-remove">Client self remove</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_SELF_REMOVE_CLIENT</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SelfRemoveClientParams {
  remove_proposal: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The proposal must be a Remove proposal for the sending client</li>
<li>The sending client must not be the last client of the user</li>
<li>The DS validates the proposal and stores it in this epoch's proposal store</li>
<li>Finally, the DS sends the <code>remove_proposal</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-14"><a class="header" href="#authentication-14">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h3 id="user-self-remove"><a class="header" href="#user-self-remove">User self remove</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_SELF_REMOVE_USER</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SelfRemoveUserParams {
  remove_proposals: Vec&lt;MlsMessage&gt;,
  group_state_ear_key: GroupStateEarKey,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The proposals must be a Remove proposals for all clients of the user</li>
<li>The DS validates the proposals and stores them in this epoch's proposal store</li>
<li>Finally, the DS sends the <code>remove_proposals</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
<li>Once the proposals are committed, the DS performs the same clean up as for the Remove User endpoint</li>
</ul>
<h4 id="authentication-15"><a class="header" href="#authentication-15">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h4 id="future-work-batch-remove-proposals"><a class="header" href="#future-work-batch-remove-proposals">Future work: Batch remove proposals</a></h4>
<p>With multiple individual proposals all parties have to verify multiple signatures. Ideally, it would be possible to batch remove proposals such that multiple clients can be removed with one proposal. This would require a custom proposal type on the level of MLS.</p>
<h3 id="send-application-message"><a class="header" href="#send-application-message">Send application message</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_SEND_MESSAGE</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SendMessageParams {
  application_message: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The DS sends the <code>application_message</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
</ul>
<h4 id="authentication-16"><a class="header" href="#authentication-16">Authentication</a></h4>
<ul>
<li>SenderId: LeafIndex</li>
</ul>
<h3 id="delete-group"><a class="header" href="#delete-group">Delete group</a></h3>
<ul>
<li>Endpoint: <code>ENDPOINT_DS_DELETE_GROUP</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct DeleteGroupParams {
  commit: MlsMessage,
  group_state_ear_key: GroupStateEarKey,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The commit must contain Remove proposals for all group members except for the sending client</li>
<li>Finally, the DS sends the <code>commit</code> to the group members by sending them on to its local QS, either for it to forward the the client's federated QS or to a local queue.</li>
<li>After sending out the commit, the DS deletes the group state.</li>
</ul>
<h4 id="authentication-17"><a class="header" href="#authentication-17">Authentication</a></h4>
<ul>
<li>SenderId: UserKeyHash</li>
</ul>
<h4 id="future-work-more-efficient-group-deletion"><a class="header" href="#future-work-more-efficient-group-deletion">Future work: More efficient group deletion</a></h4>
<p>It might be nice to just commit to a message that indicates deletion of the group. Alternatively, one could use a batch remove proposal as mentioned <a href="delivery_service.html#future-work-batch-remove-proposals">here</a>.</p>
<h2 id="ds-induced-removals"><a class="header" href="#ds-induced-removals">DS-induced removals</a></h2>
<p>In some situations, the DS will mandate the removal of a given group user by adding a remove proposal to the group's <a href="delivery_service.html#proposal-store">proposal store</a>. Every time, a group state is EAR-decrypted during to process a request, the DS performs the following operations:</p>
<p>Activity time: If the activity time of one of the clients indicates that the client has passed the maximal duration of client commit inactivity, the DS sends a <code>ClientInactivityRemoval</code> to all group members that proposes the removal of all clients that have passed that duration. It also puts the Proposals into the <code>proposal_store</code> of the group.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ClientInactivityRemoval {
  proposals: Vec&lt;MlsMessage&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>Removed queues: If the <code>sealed_queue_configs</code> vector in the <code>GroupStateDbEntry</code> is non-empty, the DS searches the <code>ClientQueueConfig</code>s of all clients for matching <code>SealedQueueConfig</code>s and distributes the following to all group members for each match. It also puts the Proposals into the <code>proposal_store</code> of the group.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct QueueDeletionRemoval {
  proposals: Vec&lt;MlsMessage&gt;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="future-work-removal-due-to-client-misbehaviour"><a class="header" href="#future-work-removal-due-to-client-misbehaviour">Future work: Removal due to client misbehaviour</a></h3>
<p>See <a href="./delivery_service/broken_state_detection.html">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../spec/authentication_service/connection_establishment.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../spec/delivery_service/group_state_encryption.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../spec/authentication_service/connection_establishment.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../spec/delivery_service/group_state_encryption.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
